# 01 基础 

## 目录(Catalog)
- 1.1 安装
    + 1.1.1 `Vue Devtools`
    + 1.1.2 直接用 `<script>` 引入
        - 1.1.2.1 `CDN`
    + 1.1.3 `NPM`
    + 1.1.4 命令行工具
    + 1.1.5 对不同构建版本的解释
        - 1.1.5.1 术语
        - 1.1.5.2 运行时 + 编译器 vs. 只包含运行时
        - 1.1.5.3 开发环境 vs. 生产环境模式
        - 1.1.5.4 `CSP` 环境
    + 1.1.6 开发版本
    + 1.1.7 `Bower`
    + 1.1.8 `AMD` 模块加载器
- 1.2 介绍
    + 1.2.1 `Vue.js` 是什么?
    + 1.2.2 起步
    + 1.2.3 声明式渲染
    + 1.2.4 条件与循环
    + 1.2.5 处理用户输入
    + 1.2.6 组件化应用构建与自定义元素的关系
    + 1.2.7 你准备好了吗?
- 1.3 `Vue` 实例
    + 1.3.1 创建一个 `Vue` 实例
    + 1.3.2 数据与方法
    + 1.3.3 实例声明周期钩子
    + 1.3.4 生命周期图示
- 1.4 模板语法
    + 1.4.1 插值
        - 1.4.1.1 文本 
        - 1.4.1.2 原始 `HTML`
        - 1.4.1.3 `Attribute`
        - 1.4.1.4 使用 `JavaScript` 表达式
    + 1.4.2 指令
        - 1.4.2.1 参数 
        - 1.4.2.2 动态参数
        - 1.4.2.3 修饰符
    + 1.4.3 缩写
        - 1.4.3.1 `v-bind` 缩写
        - 1.4.3.2 `v-on` 缩写
- 1.5 计算属性和侦听器
    + 1.5.1 计算属性
        - 1.5.1.1 基础例子
        - 1.5.1.2 计算属性缓存 vs 方法
        - 1.5.1.3 计算属性 vs 侦听属性
        - 1.5.1.4 计算属性的 setter
    + 1.5.2 侦听器
- 1.6 `Class` 与 `Style` 绑定
    + 1.6.1 绑定 `HTML Class`
        - 1.6.1.1 对象语法 
        - 1.6.1.2 数组语法
        - 1.6.1.3 用在组件上
    + 1.6.2 绑定内联样式
        - 1.6.2.1 对象语法
        - 1.6.2.2 数组语法
        - 1.6.2.3 自动添加前缀
        - 1.6.2.4 多重值 
- 1.7 条件渲染
    + 1.7.1 `v-if`
        - 1.7.1.1 在 `<template>` 元素上使用 `v-if` 条件渲染分组
        - 1.7.1.2 `v-else`
        - 1.7.1.3 `v-else-if`
        - 1.7.1.4 用 `key` 管理可复用的元素
    + 1.7.2 `v-show` 
    + 1.7.3 `v-if` vs `v-show`
    + 1.7.4 `v-if` 与 `v-for` 一起使用
- 1.8 列表渲染
    + 1.8.1 用 `v-for` 把一个数组对应为一组元素 
    + 1.8.2 在 `v-for` 里使用对象
    + 1.8.3 维护状态
    + 1.8.4 数组更新检测
        - 1.8.4.1 变异方法
        - 1.8.4.2 替换数组
        - 1.8.4.3 注意事项
    + 1.8.5 对象变更检测注意事项
    + 1.8.6 显示过滤/排序后的结果
    + 1.8.7 在 `v-for` 里使用值范围
    + 1.8.8 在 `<template>` 上使用 `v-for`
    + 1.8.9 `v-for` 与 `v-if` 一同使用
    + 1.8.10 在组件上使用 `v-for`
- 1.9 事件处理
    + 1.9.1 监听事件 
    + 1.9.2 事件处理方法
    + 1.9.3 内联处理器中的方法
    + 1.9.4 事件修饰符
    + 1.9.5 按键修饰符
        - 1.9.5.1 `.exact` 修饰符
        - 1.9.5.2 鼠标按钮修饰符
    + 1.9.6 系统修饰键
    + 1.9.7 为什么在 `HTML` 中监听事件?
- 1.10 表单输入绑定
    + 1.10.1 基础用法 
        - 1.10.1.1 文本
        - 1.10.1.2 多行文本
        - 1.10.1.3 复选框
        - 1.10.1.4 单选按钮
        - 1.10.1.4 选择框
    + 1.10.2 值绑定
        - 1.10.2.1 复选框
        - 1.10.2.2 单选按钮
        - 1.10.2.3 选择框的选项
    + 1.10.3 修饰符
        - 1.10.3.1 `.lazy`
        - 1.10.3.1 `.number`
        - 1.10.3.1 `.trim`
    + 1.10.4 在组件上使用 `v-model`
- 1.11 组件基础
    + 1.11.1 基础示例 
    + 1.11.2 组件的复用
        - 1.11.2.1 `data` 必须是一个函数
    + 1.11.3 组件的组织
    + 1.11.4 通过 `Prop` 向子组件传递数据
    + 1.11.5 单个根元素
    + 1.11.6 监听子组件事件
    + 1.11.7 通过插槽分发内容 
    + 1.11.8 动态组件
    + 1.11.9 解析 `DOM` 模板时的注意事项


## 生词(New Words)



## 内容(Content)
### 1.1 安装
- 兼容性: `Vue` 不支持 `IE8` 及以下版本, 因为 `Vue` 使用了 `IE8` 无法模拟的
  `ECMAScript 5` 特性. 但它支持所有兼容 `ECMAScript 5` 的浏览器. 
- 更新日志: 
    + 最新稳定版本: xx.xx
    + 每个版本的更新日志见: [Github](https://github.com/vuejs/vue/releases)
##### 1.1.1 `Vue Devtools`
- 在使用 Vue 时, 我们推荐在你的浏览器上安装 `Vue Devtools`. 
  它允许你在一个更友好的界面中审查和调试 Vue 应用. 
##### 1.1.2 直接用 `<script>` 引入
- 直接下载并用 `<script>` 标签引入, Vue 会被注册为一个全局变量. 
- 1.1.2.1 `CDN`
    + 对于制作原型或学习, 你可以这样使用最新版本:
      ```html
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
      ```
    + 对于生产环境, 我们推荐链接到一个明确的版本号和构建文件, 
      以避免新版本造成的不可预期的破坏:
      ```html
        <script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
      ```
    + 如果你使用原生 ES Modules, 这里也有一个兼容 ES Module 的构建文件:
      ```html
        <script type="module">
            import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.esm.browser.js'
        </script>
      ```
    + 你可以在 [cdn.jsdelivr.net/npm/uve](https://cdn.jsdelivr.net/npm/vue/)
      浏览 NPM 包的源代码.
    + Vue 也可以在 `unpkg` 和 `cdnjs` 上获取 (cdnjs 的版本更新可能略滞后). 
    + 请确认了解不同构建版本并在你发布的站点中使用生产环境版本, 把 vue.js 换成
      vue.min.js. 这是一个更小的构建, 可以带来比开发环境下更快的速度体验. 

##### 1.1.3 `NPM`
- 在用 Vue 构建大型应用时推荐使用 `NPM` 安装[1]. NPM 能很好地和诸如 `webpack`
  或 `Browserify` 模块打包器配合使用. 同时 Vue 也提供配套工具来开发单文件组件. 
  ```shell
    # 最新稳定版
    npm install vue
  ```

##### 1.1.4 命令行工具
- Vue 提供了一个官方的 `CLI`, 为单页面应用 (`SPA`) 快速搭建繁杂的脚手架. 
  它为现代前端工作流提供了 batteries-included 的构建设置. 
  只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验, 
  以及生产环境可用的构建版本. 更多详情可查阅 `Vue CLI` 的文档. 
- Notice: `CLI` 工具假定用户对 `Node.js` 和相关构建工具有一定程度的了解. 
  如果你是新手, 我们强烈建议先在不用构建工具的情况下通读指南, 
  在熟悉 Vue 本身之后再使用 `CLI`. 

##### 1.1.5 对不同构建版本的解释
|    | UMD | CommonJS| ES Module(基于构建工具使用)| ES Module(直接用于浏览器)|
|:------|:------|:------|:------|:------|
|完整版本|`vue.js`|`vue.common.js`|`vue.esm.js`|`vue.esm.browser.js`|
|只包含运行时版| `vue.runtime.js`| `vue.runtime.common.js` | `vue.runtime.esm.js`||
|完整版(生产环境)|`vue.min.js`| | | `vue.esm.browser.min.js` |
|只包含运行时版(生产环境)| `vue.runtime.min.js` ||||
- 1.1.5.1 术语
    + 完整版: 同时包含编译器和运行时的版本. 
    + 编译器: 用来将模板字符串编译成为 JavaScript 渲染函数的代码. 
    + 运行时: 用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码. 
      基本上就是除去编译器的其它一切. 
    + `UMD`: `UMD` 版本可以通过 `<script>` 标签直接用在浏览器中. 
      jsDelivr CDN 的 `https://cdn.jsdelivr.net/npm/vue`
      默认文件就是运行时 + 编译器的 UMD 版本 (`vue.js`). 
    + `CommonJS`: `CommonJS` 版本用来配合老的打包工具比如
      `Browserify` 或 `webpack 1`. 这些打包工具的默认文件 (`pkg.main`) 
       是只包含运行时的 `CommonJS` 版本 (`vue.runtime.common.js`). 
    + `ES Module`: 从 2.6 开始 Vue 会提供两个 `ES Modules` (ESM) 构建文件: 
        - 为打包工具提供的 `ESM`: 为诸如 `webpack 2` 或 `Rollup` 提供的现代打包工具. 
          `ESM` 格式被设计为可以被静态分析, 所以打包工具可以利用这一点来进行
           `tree-shaking` 并将用不到的代码排除出最终的包. 
           为这些打包工具提供的默认文件 (`pkg.module`) 是只有运行时的 `ES Module`
           构建 (`vue.runtime.esm.js`). 
        - 为浏览器提供的 `ESM` (2.6+): 用于在现代浏览器中通过 
          `<script type="module">` 直接导入. 
- 1.1.5.2 运行时 + 编译器 vs. 只包含运行时
    + 如果你需要在客户端编译模板(比如传入一个字符串给 `template` 选项,
      或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板), 那么就需要加上编译器. 即完整版:

      (Additional Description: 这一段实际上想表达的是, 只要你用到了 `template` 
      模板相关的语法, 就需要使用带有 `编译器` 的版本, 因为 `运行时` 版本里不带`编译器`.
      如果你待插入到页面中的 DOM 像下面代码一样是使用 `render()` 函数渲染的,
      那么就不需要 `编译器`, 因为 `render()` 函数就是一个 js 方法, 所以不需要.)
      ```js
        // - 需要编译器
        new Vue({
            template: '<div>{{ hi }}</div>'
        });

        // - 不需要编译器
        new Vue({
            render(h) {
                return h('div', this.hi)
            }
        })
      ```
      当使用 `vue-loader` 或 `vueify` 的时候, `*.vue`
      文件内部的模板会在构建时预编译成 JavaScript.
      你在最终打好的包里实际上是不需要编译器的, 所以只用运行时版本即可. (Notiec:
      这里所说的运行时版本, 大概就是上面表格中的 `vue.runtime.js`).

      因为运行时版本相比完整版体积要小大约 30%, 所以应该尽可能使用这个版本.
      如果你仍然希望使用完整版, 则需要在打包工具里配置一个别名:
    + `Webpack`:
      ```js
        module.exports = {
            // other code...
            resolve: {
                alias: {
                    // - 用 webpack 1 时需要 `vue/dist/vue.common.js`
                    'vue$': `vue/dist/vue.esm.js`,
                }
            }
        }
      ```
    + `Rollup`:
      ```js
        const alias = require('rollup-plugin-alias');
        rollup({
            // ...
            plugins: [
                alias({
                    'vue': require.resolve('vue/dist/vue.esm.js')
                })
            ]
        })
      ```
    + `Browserify`: 添加到你项目的 `package.json` 中:
      ```js
        {
            // ...
            "browser": {
                "vue": "vue/dist/vue.common.js"
            }
        }
      ```
    + `Parcel`: 添加到你项目的 `package.json` 中:
      ```js
        {
            // ...
            "alias": {
                "vue": "./node_modules/vue/dist/vue.common.js"
            }
        }
      ```

- 1.1.5.3 开发环境 vs. 生产环境模式
    + 对于 `UMD` 版本来说,
      开发(development)环境/生产(production)环境模式是硬编码好的:
      开发环境下用未压缩的代码, 生产环境下使用压缩后的代码.
      (Note: `UMD` 见: `../../# Webpack-Learning/Webpack-README.MD`)

      `CommonJS` 和 `ES Module` 版本是用于打包工具的, 因为我们不提供压缩后的版本.
      你需要自行将最终的包进行压缩.

      `CommonJS` 和 `ES Module` 版本同时保留原始的 `process.env.NODE_ENV` 检测,
      以决定它们应该运行在什么模式下.
      你应该使用适当的打包工具配置来替换这些环境变量以便控制 Vue 所运行的模式.
      把 `process.env.NODE_ENV` 替换为字符串字面量同时可以让 `UglifyJS`
      之类的压缩工具完全丢掉仅供开发环境的代码, 以减少最终的文件尺寸.
    + `Webpack`: 在 `webpack 4+` 中, 你可以使用 `mode` 选项:
      ```js
        module.exports = {
            mode: 'production'
        }
      ```
      但是在 `webpack 3` 及其更低版本中, 你需要使用 `DefinePlugin`:
      ```js
        var webpack = require('webpack');
        module.exports = {
            // ...
            plugins: [
                // ...
                new webpack.DefinePlugin({
                    'process.env': {
                        NODE_ENV: JSON.stringify('production')
                    }
                })
            ]
        }
      ```
    + `Rollup` 使用 `rollup-plugin-replace`:
      ```js
        const replace = require('rollup-plugin-replace');
        rollup({
            // ...
            plugins: [
                replace({
                    'process.env.NODE_ENV': JSON.stringify('production')
                })
            ]
        }).then(...)
      ```
    + `Browserify` 为你的包应用一次全局的 `envify` 转换.
      ```shell
        NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js
      ```
    +  你也可以移步到 "生产环境部署": `./05-工具.md/5.4 生产环境部署`
- 1.1.5.4 `CSP` 环境
    + 有些环境, 如 Goolge Chrome Apps, 会强制应用
      `内容安全策略 (CSP: Content Security Policy)` 不能使用 `new Function()`
      对表达式求值. 这时可以用 CSP 兼容版本. 完整版本依赖于该功能来编译模板,
      所以无法在这些环境下使用.

      另一方面, 运行时版本则是完全兼容 CSP 的. 当通过 `webpack` + `vue-loader`
      或者 `Browserify` + `vueify` 构建时, 模板(template)将被编译为 `render` 函数,
      可以在 CSP 环境中完美运行.

##### 1.1.6 开发版本
- 重要: `GitHub` 仓库的 `/dist` 文件夹只有在新版本发布时才会提交. 
  如果想要使用 `GitHub` 上 Vue 最新的源码, 你需要自己构建！
  ```shell
    git clone https://github.com/vuejs/vue.git node_modules/vue
    cd node_modules/vue
    npm install
    npm run build
  ```
##### 1.1.7 `Bower`
- `Bower` 只提供 `UMD` 版本. 
  ```shell
    # 最新稳定版本
    bower install vue
  ```
##### 1.1.8 `AMD` 模块加载器
- 所有 `UMD` 版本都可以直接用作 `AMD` 模块.
  (Note: `AMD` 见: `../../# Webpack-Learning/Webpack-README.MD`)
  

### 1.2 介绍
##### 1.2.1 `Vue.js` 是什么?
- Vue (读音 `/vjuː/`, 类似于 view) 是一套用于构建用户界面的渐进式框架.
  与其它大型框架不同的是, Vue 被设计为可以自底向上逐层应用. Vue 的核心库只关注视图层,
  不仅易于上手, 还便于与第三方库或既有项目整合. 另一方面, 
  当与现代化的工具链以及各种支持类库结合使用时, 
  Vue 也完全能够为复杂的单页应用提供驱动. 
##### 1.2.2 起步
- 略
##### 1.2.3 声明式渲染
- Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统,
  看下面这个示例:
  ```vue
    // - Notice: Vue 官网文档是使用的 `script` 方式加载 Vue 的,
    //   所以示例都是在 `*.html` 中的写法; 但是上面说了, 我们使用 Vue CLI
    //   生成的模板项目, 所以我们写的代码都是在 `*.vue` 组件内的写法. 
    //   后面的代码同理. 测试示例见: `../../vue-source-learning-example`
    //   Vue CLI 生成模板项目见 Vue CLI 文档.  
    <template>
        <div id="app">
            {{ message }}
        </div>
    </template>

    <script>
        export default {
            name: 'App',
            // - Notice: 在 Vue 中, 组件中的 data 属性, 一定要写成函数形式,
            //   因为组件是要复用的; 例如已创建了 Vue 构造函数, 接下来我们创建 3 个
            //   Vue 构造函数的实例(e.g. vm1, vm2, vm3), Vue 内部会把当前
            //   `export default {}` 这个字面量对象(即: `options`), 处理后, 赋值给
            //   `Vue.prototype.$data`(即: Vue 原型上的 `$data`) 属性,
            //   但是 JS 原型上的属性是被所有实例共享的, 如果 `data` 此时是一个对象
            //   (即: `data: {message: 'Hello Vue!'}`) 
            //   赋值给 $data 那么就会变成这种情形: 
            //   `Vue.prototype.$data = {message: 'Hello Vue!'}`;
            //   现在问题就出现了, 当第一个 vm1 设置了自己想要的 message 值后走开了, 
            //   接着第二个 vm2 就通过 vm2.$data.message = "I have changed!", 
            //   轻而易举就把 message 给更改了... 所以为了解决这种问题, Vue 规定
            //   组件中的 data 属性必须是一个函数(方法), 此函数利用 `return {}`
            //   的方式返回了一个创建的对象字面量对象, 因此每个实例(vm1, vm2,
            //   vm3)可以维护一份被返回对象的独立的拷贝. 
            // - 如果上面没看懂也先不用着急, 详细会在后面的
            //   `1.11.2.1 data 必须是一个函数` 中做详细的示例讲解.
            data() {
                return {
                    message: 'Hello Vue!'
                }
            }
        }
    </script>
  ```
  ```js
    // - ../../vue-source-learning-example/src/main.js
    import Vue from 'vue';
    import App from './App.vue';
    Vue.config.productionTip = false;
    new Vue({
        render: h => h(App),
    }).$mount('#app')
  ```
- 除了上面的 `文本插值`, 我们还可以像这样来绑定元素属性(`attribute`): 
  ```vue
    // - 示例路径: `../../vue-source-learning-example/src/components/1.2.3.vue`
    <template>
        <div>
            <span v-bind:title="message">
                鼠标悬停几秒钟会显示此处动态绑定的提示信息!
            </span>
        </div>
    </template>

    <script>
        export default {
            data() {
                return {
                    message: '页面加载于' + new Date().toLocaleString()
                }
            }
        }
    </script>
  ```
  这里我们遇到了一点新东西. 你看到的 `v-bind:attribute` 被称为 `指令`.
  指令带有前缀 `v-`, 以表示它们是 Vue 提供的特殊 `attribute(属性)`. 可能你已经猜到了,
  它们会在渲染的 DOM 上应用特殊的响应式行为. 在这里, 该指令的意思是: 将这个元素节点的
  `title` 属性和 Vue 实例的 `message` 属性保持一致.

  当然你可以在浏览器中更改 `message` 的值, 安装 `Vue-DevTools` 插件后,
  在 `Components` 组件下, 点击 `<App>` 展开下拉后, 点击 `<Chapter123>`,
  更改右侧的 `message` 后, 点击保存. 鼠标再次移动上面的文字上, 提示内容已经更新了.  

##### 1.2.4 条件与循环
- 控制切换一个元素是否显示也相当简单:
  ```vue
    // - 示例路径: `../../vue-source-learning-example/src/App.vue`
    <template>
        <div id="app">
            <img alt="Vue logo" src="./assets/logo.png">
            <p v-if="seen">现在你看到我了!</p>
            <HelloWorld msg="Welcome to Your Vue.js App"/>
            <Demo123/>
        </div>
    </template>

    <script>
        import HelloWorld from './components/HelloWorld.vue';
        import Demo123 from './components/1.2.3.vue';

        export default {
            name: 'App',
            data() {
                return {
                    seen: true,
                }
            },
            components: {
                HelloWorld,
                Demo123
            }
        }
    </script>
  ```
  继续按照上面的方式在浏览器的 `Vue-DevTools` 中更该 `seen = false`,
  便会发现上面的显示消息消失了.

  这个例子演示了我们不仅可以把数据绑定到 DOM 文本或 attribute, 还可以绑定到 DOM 结构.
  此外, Vue 也提供一个强大的过度效果系统,
  可以在 Vue 插入/更新/移除元素时自动应用`过渡效果`(`./03-过渡与动画.md`)

  还有其它很多指令, 每个都有特殊的功能. 例如, `v-for`
  指令可以绑定数组的数据来渲染一个项目列表:
  ```vue
    // - `App.vue`
    <template>
        <!--其他代码省略-->
        <Demo124/>
    </template>
    <script>
        // 其他 import 省略
        import Demo124 from './components/1.2.4';
        export default {
            name: 'App',
            data() {
                // ...
            }
            components: {
                HelloWorld,
                Demo123,
                Demo124,
            }
        }
    </script>
  ```
  ```vue
    // - 示例路径: `../../vue-source-learning-example/src/components/1.2.4.vue`
    <template>
        <div class="app-4">
            <h2>1.2.4: v-for</h2>
            <ol>
                <li v-for = 'todo in todos' :key="todo.index">
                    {{ todo.text }}
                </li>
            </ol>
        </div>
    </template>

    <script>
        export default {
            name: 'Demo124',
            data() {
                return {
                    todos:[
                        {text: '学习 JavaScript', index: 0},
                        {text: '学习 Vue', index: 1},
                        {text: '建个项目', index: 2},
                    ]
                }
            }
        }
    </script>

    <style scoped>
        .app-4 {
            margin: 10px auto;
            height: 200px;
            width: 400px;
            float: left;
            background: #33cc99;
        }
    </style>
  ```
  在控制台里的 `Vue-DevTools` 左侧选中 `<Demo124>`, 在右侧的 `data` 下的 `todos`
  数组中点击 `+` 号添加一项: `{"text":"添加一项","index":3}`
  (tip: 注意这里添加到数据格式是 `JSON`, 不是对象字面量), 上面的视图中便自动更新.

##### 1.2.5 处理用户输入
- 为了让用户和你的应用进行交互, 我们可以使用 `v-on` 指令添加一个事件监听器,
  通过它调用在 Vue 实例中定义的方法:
  ```js
    // - App.vue: `../../vue-source-learning-example/src/App.vue`
    // - 示例路径: `../../vue-source-learning-example/src/components/1.2.5.vue`
  ```
  注意在 `reverseMessage` 方法中, 我们更新了应用的状态, 但并没有触碰 DOM --
  所有的 DOM 操作都由 Vue 来处理, 你编写的代码只需要关注逻辑层面即可.

  Vue 还提供了 `v-model` 指令, 它能轻松实现表单输入和应用状态之间的双向绑定.
  ```js
    // - App.vue: `../../vue-source-learning-example/src/App.vue`
    // - 示例路径: `../../vue-source-learning-example/src/components/1.2.5.vue`
  ```
##### 1.2.6 组件化应用构建与自定义元素的关系
- 组件系统是 Vue 的另一个重要概念, 因为它是一种抽象, 
  允许我们使用小型、独立和通常可复用的组件构建大型应用. 仔细想想,
  几乎任意类型的应用界面都可以抽象为一个组件树:

  <img src="./vue-document-images/components.png">

  在 Vue 里, **一个组件本质上是一个拥有预定义选项的一个 Vue 实例**.
  在 Vue 中注册组件很简单:
  ```js
    // -定义名为 todo-item 的新组件
    Vue.component('todo-item', {
        template: '<li>这是一个代办项</li>'
    })
    var app = new Vue(...)
  ```
  现在你可以用它构建另一个组件模板:
  ```vue
    <ol>
        <!-- 创建一个 todo-item 组件的实例 -->
        <todo-item></todo-item>
    </ol>
  ```
  ......

  Vue 文档中接下来给出了一个组件示例, 我觉得实际上并不合适, 因为其中牵扯到很多东西,
  组件后面会讲到, 这个示例就暂时先略过......
- **与自定义元素的关系**: 
    + 你可能已经注意到 Vue 组件非常类似于**自定义元素**
      (e.g. `App.vue` 文件 `template` 内的 `<HelloWorld>`) --
      它是 `Web 组件规范`的一部分, 这是因为 Vue 的组件语法部分参考了该规范.
      例如 Vue 组件实现了 `Slot API` 与 `is` 属性(`attribute)`.
      但是, 还是有几个关键差别:
        - Web Components 规范已经完成并通过, 但未被所有浏览器原生实现. 目前
          Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components.
          相比之下, Vue 组件不需要任何 polyfill, 并且在所有支持的浏览器
          (IE9 及更高版本) 之下表现一致. 必要时, 
          Vue 组件也可以包装于原生自定义元素之内. 
        - Vue 组件提供了纯自定义元素所不具备的一些重要功能,
          最突出的是跨组件数据流、自定义事件通信以及构建工具集成. 
    + 虽然 Vue 内部没有使用自定义元素, 不过在应用使用自定义元素、
      或以自定义元素形式发布时, 依然有很好的互操作性. Vue CLI 也支持将 Vue
      组件构建成为原生的自定义元素. 
##### 1.2.7 你准备好了吗?
- 我们刚才简单介绍了 Vue
  核心最基本的功能——本教程的其余部分将更加详细地涵盖这些功能以及其它高级功能,
  所以请务必读完整个教程!

  
### 1.3 `Vue` 实例
##### 1.3.1 创建一个 `Vue` 实例
- 每个 Vue 应用都是从创建一个新的 `Vue` 构造函数的实例开始的, 如下:
  ```js
    var vm = new Vue({
        // - 选项
    })
  ```
  虽然没有完全遵循 `MVVM` 模型, 但是 Vue 的设计也受到了它的启发. 
  因此在文档中经常会使用 `vm` (`ViewModel 视图模型`) 这个变量名表示 Vue 实例. 

  当创建一个 Vue 实例时, 你可以传入一个**选项对象 (options)**.
  这篇教程主要描述的就是如何使用这些选项来创建你想要的行为. 作为参考,
  你也可以在 `API 文档` 中浏览完整的选项列表. 

  一个 Vue 应用由一个通过 `new Vue` 创建的**根 Vue 实例**, 以及可选的嵌套的, 
  可复用的组件树组成. 举个例子, 一个 todo 应用的组件树可以是这样的:
  ```base
    根实例
    |- TodoList
        |- TodoItem
        |   |- DeleteTodoButton
        |   |- EditTodoButton
        |- TodoListFooter
        |   |- ClearTodosButton
        |   |- TodoListStatistics
  ```
  我们会在稍后的 `组件系统`(当前文件的 `1.11 组件基础`) 章节具体展开. 不过现在,
  你只需要明白所有的 Vue 组件都是 Vue 实例, 并且接受相同的选项对象
  (一些根实例特有的选项除外).
##### 1.3.2 数据与方法
- 当一个 Vue 实例被创建时, 它将 `data`对象中所有的属性加入到 Vue 的
  `响应式系统`(`./07-内在(深入响应式原理).md`). 当这些属性的值发生改变时,
  视图将会产生 "响应", 即匹配更新为新的值.
  ```js
    // - Added Before: 下面这些代码是运行在, 以 `<script>` 方式引入 Vue 的单个 
    //   `*.html` 文件中的. 在上面的 `1.1.5 对不同构建版本的解释` 中说过,
    //   通过 `<script>` 方式引入的 Vue 是完整版的(即: 同时包含 "编译器" 和
    //   "运行时" 的), 然而我们现在以 Vue CLI 的方式生成的模板项目, 编译是在控制台中
    //   运行 npm ... 编译代码实现的. 下列代码, 如果想测试, 可自行创建一个 html
    //  引入 Vue 来执行即可.

    // - 我们的数据对象
    var data = { a: 1 };
    // - 把该对象加入到一个 Vue 实例中
    var vm = new Vue({
        data: data
    });
    // - 获取这个实例上的属性, 返回源数据中对应的字段
    vm.a = data.a;  // true
    // - 设置属性也会影响到原始数据
    vm.a = 2;
    console.log(data.a);    // 2
    // - 反之亦然
    data.a = 3;
    console.log(vm.a);  // 3
  ```
  当这些数据改变时, 视图会进行重渲染. 值得注意的是只有当实例被创建时就已经存在于
  `data` 中的属性才是响应式的. 也就是说如果你添加一个新的属性, 比如:
  ```js
     vm.b = 'hi';
  ```
  那么对 `b` 的改动将不会触发任何视图的更新. 如果你知道你会在晚些时候需要一个属性,
  但是一开始它为空活不存在, 那么你仅需要设置一些初始值. 比如:
  ```js
    data: {
        newTodoText: '',
        visitCount: 0,
        hideCompletedTodos: false,
        todos: [],
        error: null
    }
  ```
  但是, 这里唯一的例外是使用 `Object.freeze()`, 这会阻止修改现有的属性,
  也意味着响应系统无法再追踪变化.
  ```js
    var obj = {
        foo: 'bar'
    };
    Object.freeze(obj);
    new Vue({
        el: '#app',
        data: obj
    })
  ```
  ```html
    <div id="app">
        <p>{{ foo }}</p>
        <!-- 这里的 `foo` 不会更新 -->
        <button @click="foo = 'baz'"></button>
    </div>
  ```
  除了数据属性, Vue 实例还暴露了一些有用的实例属性与方法. 它们都有前缀 `$`, 
  以便于用户定义的属性区分开来. 例如:
  ```js
    var data = { a: 1};
    var vm = new Vue({
        el: '#example',
        data: data
    });
    vm.$data === data;  // true
    vm.$el === document.getElementById('example');  // true

    // - $watch 是一个实例方法
    vm.$watch('a', function(newValue, oldValue) {
        // - 这个回调将在 `vm.a` 改变后调用.
    })
  ```
  以后你可以在 `API 参考` 中查阅到完整的实例属性和方法的列表.
##### 1.3.3 实例声明周期钩子
- 每个 Vue 实例在被创建时都要经过一系列的初始化过程 -- 例如, 需要设置数据监听,
  编译模板, 将实例挂载到 DOM 并在数据变化时更新 DOM 等.
  同时在这个过程中也会运行一些叫做 `生命周期钩子` 的函数,
  这给了用户在不同阶段添加自己代码的机会.

  比如, `created` 钩子可以用来在一个实例被创建之后执行代码:
  ```vue
    // - App.vue: `../../vue-source-learning-example/src/App.vue`
    // - 示例路径: `../../vue-source-learning-example/src/components/1.3.3.vue`
    <template>
        <div id="app-133">
            <h2>1.3.3: 实例生命周期钩子</h2>
        </div>
    </template>

    <script>
        export default {
            name: 'Demo133',
            data() {
                return {
                    a: 1
                }
            },
            created() {
                // `this` 指向 vm 实例
                console.log('a is:' + this.a)   // "a is: 1"
            }
        }
    </script>
  ```
  也有一些其他的钩子, 在实例生命周期的不同阶段被调用, 如 `mounted`, `updated` 和
  `destroyed`. 生命周期钩子的 `this` 上下文指向调用它的 Vue 实例.
- **Warning**: 不要在选项属性或回调上使用箭头函数, 比如
  `created: () => console.log(this.a)` 或
  `vm.$watch('a', newValue => this.myMethod())`. 因为箭头函数并没有 `this`,
  `this` 会作为变量一直向上级词法作用域查找, 直至找到为止, 经常导致
  `Uncaught TypeError: Cannot read property of undefined` 或 
  `Uncaught TypeError: this.myMethod is not a function` 之类的错误. 
##### 1.3.4 生命周期图示
- 下图展示了实例的生命周期. 你不需要立马弄明白所有的东西, 不过随着你的不断学习和使用,
  它的参考价值会越来越高.

  <img src="./vue-document-images/lifecycle-1.png"
    style="width: 76%;">

  如果使用构造生成文件(例如: 构造单文件组件), 模板编译将提前执行.


### 1.4 模板语法
- Vue.js 使用基于 HTML 的模板语法, 它允许你声明式地将渲染的 DOM 绑定至底层 Vue
  实例的数据(Note: 通俗的理解: 要渲染的 DOM 都是建立在 Vue 实例的数据之上的).
  所有 Vue.js 的模板都是合法的 HTML, 所以能被遵循规范的浏览器和 HTML 解析器解析.
  
  在底层的实现上, Vue 将模板编译成虚拟 DOM 渲染函数. 结合响应系统,
  Vue 能够智能地计算出最少需要重新渲染多少组件, 并把 DOM 操作次数减到最少. 

  如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量, 你也可以不用模板,
  直接写 `渲染(render)函数`(`./04-可复用性与组合.md` - `4.3 渲染函数 & JSX`),
  使用可选的 JSX 语法. 

##### 1.4.1 插值
- 1.4.1.1 文本
    + 数据绑定最常见的形式就是使用 `Mustache`(胡子)语法(双大括号)的文本插值:
      ```vue
        <span>Message: {{ msg }}</span>
      ```
      Mustache 标签将会被 Vue 实例中对应数据上的 `msg` 属性的值所替换. 无论何时,
      绑定的数据对象上的 `msg` 属性只要发生了改变, 插值出的内容也会立即发生改变.

      通过使用 [`v-once`指令](https://cn.vuejs.org/v2/api/#v-once),
      你也能执行一次性的插值, 当数据改变时, 插值处的内容不会更新.
      但请留心这会影响到该节点上的其它数据绑定:
      ```vue    
        <span v-once>这个将不会改变: {{ msg }}}</span>
      ```
- 1.4.1.2 原始 `HTML`
- 双大括号会将数据解释为普通文本, 而非 HTML 代码. 为了输出真正的 HTML, 你需要使用
  [`v-html`指令](https://cn.vuejs.org/v2/api/#v-html):
  ```vue
    // - 示例: `../../vue-source-learning-example/src/components/1.4.1.2.vue`
    <template>
        <div id="app-1412" class="default-div">
            <h2>1.4.1.2: 原始 HTML</h2>
            <p>使用 Mustache: {{rawHtml}}</p>
            <p>使用 v-html 指令: <span v-html="rawHtml"></span></p>
        </div>
    </template>

    <script>
        export default {
            name: 'app-1412',
            data() {
                return {
                    rawHtml: '<span style="color:red">This should be red.</span>'
                }
            }
        }
    </script>
  ```
- **Warning**: 你的站点上动态渲染的任意 HTML 可能都会非常危险, 因为它很容易导致
  [XSS 攻击](https://www.wikiwand.com/zh/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC).
  请只对可信任内容使用 HTML 插值, **绝不要**对用户提供的内容使用插值.
- 1.4.1.3 `Attribute`(属性)
    + Mustache 语法不能作用在 HTML attribute 上, 遇到这种情况应该使用 `v-bind` 指令:
      ```vue
        <div v-bind:id="dynamicId"></div>
      ```
      对于布尔 attribute(默认: 它们只要存在就意味着为 `true`), `v-bind`
      工作起来略有不同, 看下这个例子:
      ```vue
        <button v-bind:disabled="isButtonDisabled">Button</button>
      ```
      如果 `isButtonDisabled` 的值是 `null`, `undefined` 或 `false`, 则
      `disabled` 属性甚至不会被包含在渲染出来的 `<button>` 元素中.
- 1.4.1.4 使用 `JavaScript` **表达式**
    + **Added**: 表达式是什么?
        - (1) [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators)
          文档给出的回答是: 表达式是一组代码的集合,它返回一个值.
          每个合法的表达式都能计算成某个值. 例如:

          `x = 7` 是一个表达式, 该表达式使用 `=` 运算符将值 7 赋值给变量 `x`.
          这个表达式自己的值等于 7.
          
          `3 + 4` 也是一个表达式, 该表达式使用 `+` 运算符把 3 和 4 加到一起,
          但并没有把结果 7 赋值给一个变量.

          JavaScript 有一下表达式类型:
            + <1> 算数: 得出一个数字, 例如: 3.14159.
            + <2> 字符串: 得出一个字符串. 例如: 'Fred' 或 '234'.
            + <3> 逻辑值: 得出 `true` / `false`.
            + <4> 基本表达式: JS 中基本的关键字和一般表达式.
                - Q: JS 的基本关键字是可以查到, 但 "一般表达式" 是什么鬼?
            + <5> 左值表达式: 分配给左值.
                - Q: 这个左值表达式是指 `=`(赋值操作符)? 这文档写的是给人看的吗? 
        - (2) 第一种 MDN 给出的解释有点杂乱, 所以我添加上之前在
          `《C++ Primer》` 中看到的对 "表达式" 下的定义:
            + 表达式(expression): 在 C++ 中, 一个表达式产生一个计算结果,
              它由一个或多个运算对象和(通常是)一个运算符组成. (是不是清晰很多!!!)
    + 迄今为止, 在我们的模板中, 我们一直都只绑定简单的属性键值. 但实际上,
      对于所有的数据绑定, Vue.js 都提供了完全的 JavaScript 表达式支持. 例如:
      ```vue
        <!--(1)-->
        {{ number + 1 }}

        <!--(2)-->
        {{ ok ? 'YES' : 'NO' }}

        <!--(3)-->
        {{ message.split('').reverse().join('') }}

        <!--(4)-->
        <div v-bind:id="'list-' + id"></div>
      ```
      这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析. 有个限制是,
      每个绑定都只能包含 **单个表达式**, 所以下面的例子都不会生效.
      ```vue
        <!--这是语句, 不是表达式-->
        {{ var a = 1 }}

        <!--流控制语句也不会生效, 请使用三元表达式(三目运算符)-->
        {{ if(ok){return message }}
      ```
    + **Warning**: 模板表达式都被放在沙盒中, 只能访问
      [全局变量的一个白名单](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9),
      如 `Math` 和 `Date`. 你不应该在模板表达式中试图访问用户定义的全局变量.
##### 1.4.2 指令
- `指令(Directives)` 是带有 `v-` 前缀的特殊 attribute. 指令 attribute
  的预期值是 **单个 JavaScript 表达式** (`v-for` 是例外情况, 稍后我们再讨论).
  指令的职责是, 当表达式的值改变时, 当其产生的连带影响, 响应式地作用于 DOM.
  回顾我们在介绍中看到的例子:
  ```vue
    <p v-if="seen">现在你看到我了</p>
  ```
  这里, `v-if` 指令将给句表达式 `seen` 值的真假来插入/移除 `<p>` 元素.
  
  **Added**: 注意这里的 **插入/移除 `<p>` 元素**,
  Vue 从新编译后确实是把 `<p>` 元素从页面中移除了而不是隐藏,
  在下面的文档中会讲 `v-show`指令(`1.7.2 v-show`), `v-show` 才是把元素隐藏.)
- 1.4.2.1 参数
    + 一些指令(directives)能够接受一个 "参数", 在指令名称之后以冒号表示.
      例如, `v-bind` 指令可以用于响应式地更新 HTML attribute:
      ```html
        <a v-bind:href="url">...</a>
      ```
      在这里 `href` 就是参数, 告知 `v-bind` 指令将该元素的 `href`属性
      与表达式 `url` 的值绑定.
    + 另一个例子是 `v-on` 指令, 它用于监听 DOM 事件:
      ```html
        <a v-on:click="doSomething">...</a>
      ```
      在这里参数是监听的事件名. 我们在后面也会更详细地讨论事件处理.
- 1.4.2.2 动态参数
    + > 2.6.0 新增
    + 从 2.6.0 开始, 可以用方括号括起来的 JavaScript 表达式作为一个指令的参数:
      ```vue
        <!-- 注意, 参数表达式的写法存在一些约束, 如下面的要讲的
          "对动态参数表达式的约束" 中所述.-->
        <a v-bind:[attributeName]="url">...</a>
      ```
      这里的 `attributeName` 会被作为一个 JavaScript 表达式进行动态求值,
      求得的值将会作为最终的参数来使用. 例如, 如果你的 Vue 实例有个 `data`
      属性 `attributeName`, 其值为 `href`, 那么这个绑定将等价于 `v-bind:href`.

      同样地, 你可以使用动态参数为一个动态的事件名绑定处理函数:
      ```vue
        <a v-on:[eventName]="doSomething">...</a>
      ```
      在这个示例中, 如果 `eventName` 的值为 `focus`, `v-on:[eventName]`
      就等价于 `v-on:focus`.
    + **动态参数`值`约束**:
      
      动态参数预期会求出一个字符串, 异常情况下值为 `null` 这个特殊的 `null`
      值可以被显性地用于移除绑定. 任何其它非字符串类型的值都将会触发一个警告.
    + **动态参数`表达式`约束**:
      
      动态参数表达式有一些语法约束, 因为某些字符, 如`空格`和`引号`, 放在 HTML
      属性(attribute) 名里是无效的. 例如:
      ```html
        <!-- 这会触发一个编译警告 -->
        <a v-bind:['foo' + bar]="value">...</a>
      ```
      变通的方法是使用没有空格或引号的的表达式, 或用计算属性替代这些复杂表达式.

      在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板),
      还需要避免使用大写字符来命名键名, 因为浏览器会把 attribute
      名全部强制转换为小写:
      ```vue
        <!-- 在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`.
        除非在实例中有一个名为 `someattr` 的 property, 否则代码不会工作. -->
        <a v-bind:[someAttr]="value">...</a>
      ```
    
- 1.4.2.3 修饰符
    + `修饰符(modifier)` 是以半角句号 `.` 指明的特殊后缀,
      用于指出一个指令应该以特殊方式绑定. 例如: `.prevent` 修饰符告诉 `v-on`
      指令对于触发的事件调用 `event.preventDefault()`(取消事件的默认行为):
      ```vue
        <form v-on:submit.prevent="onSubmit">...</form>
      ```
      在接下来对 `v-on` 和 `v-for` 等功能的探索中, 你会看到修饰符的其他例子.

##### 1.4.3 缩写
- 
- 1.4.3.1 `v-bind` 缩写
- 1.4.3.2 `v-on` 缩写