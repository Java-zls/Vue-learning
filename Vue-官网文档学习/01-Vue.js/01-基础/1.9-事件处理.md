# 1.9 事件处理

## 目录(Catalog)
- 1.9 事件处理
    + 1.9.1 监听事件 
    + 1.9.2 事件处理方法
    + 1.9.3 内联处理器中的方法
    + 1.9.4 事件修饰符
    + 1.9.5 按键修饰符
        - 1.9.5.1 `.exact` 修饰符
        - 1.9.5.2 鼠标按钮修饰符
    + 1.9.6 系统修饰键
    + 1.9.7 为什么在 `HTML` 中监听事件?

## 生词(New Words)
- **prevent [pri'vɛnt] --vt.防止; 预防; 阻止; 避免;**
    + prevent progress. 妨碍进步[进行].
    + prevent traffic accidents. 防止交通事故.
    + We prevented the fire from spreading. 我们阻止火势蔓延.
    + I was prevented from attending by a cold. 感冒使得我不能出席.
    + Business prevented his going = Business prevented him going.
      他因有事而不能去.
- **propagation [ˌprɒpə'ɡeɪʃən] --n.传播; 繁殖;**
    + the propagation of the principles of science. 科学原理的传播.
- **passive ['pæsɪv] --adj.被动的, 消极的, 被动语态的.  --n.被动语态**
    + passive DNS. 被动 DNS
    + passive smoking 被动吸烟; 吸二手烟
    + We should translate this sentence in passive voice.
      我们应该用被动语态翻译这个句子.
- **exact [ɪg'zækt] --adj.精确的, 确切的**
    + Do you have any idea of the exact date? 你知道具体是在哪一天吗？
    + See `npm help json` for definitive documentation on these fields
      and exactly what they do.
      请参阅 `npm help json` 以获取有关这些字段的权威文档及其确切功能.
      


## 内容(Content)
### 1.9 事件处理
##### 1.9.1 监听事件 
- 可以用 `v-on` 指令监听 DOM 事件, 并在触发时运行一些 JavaScript 代码.示例:
  ```vue
    <template>
        <div id="app191" class="default-div">
            <h2>1.9.1: 监听事件</h2>
            <div id="example-1">
                <button @click="counter += 1">Add 1</button>
                <p>The button above has been clicked {{ counter }} times.</p>
            </div>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo191',
            data() {
                return {
                    counter: 0
                }
            }
        }
    </script>
  ```

##### 1.9.2 事件处理方法
- 然而许多事件处理逻辑会更为复杂, 所以直接把 JavasScript 代码写在 `v-on`
  指令中是不可行的. 因此 `v-on` 还可以接收一个需要调用的方法名称. 示例如下:
  ```vue
    <template>
        <div id="app192" class="default-div">
            <h2>1.9.2: 事件处理方法</h2>
            <div id="example-2">
                <!-- `greet` 是下面定义的方法名 -->
                <button @click="greet">Greet</button>
                <p> {{ target }}</p>
            </div>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo191',
            data() {
                return {
                    counter: 0,
                    target: ''
                }
            },
            methods: {
                greet: function(event) {
                    // `this` 在方法里指向当前 Vue 实例
                    console.log('Hello ' + this.name + '!');
                    // `event` 是原生 DOM 事件
                    if (event) {
                        this.target
                            = "Getting from " + event.target.tagName + "'s greeting!"
                    }
                }
            }
        }
    </script>
  ```

##### 1.9.3 内联处理器中的方法
- 除了直接绑定到一个方法, 也可以在内联 JavaScript 语句中调用方法. 例如:
  ```vue
    <template>
        <div id="example-3">
            <button :click="say('hi')">Say hi</button>
            <button :click="say('what')">Say what</button>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo193',
            methods: {
                say: function(message) {
                    console.log(message)
                }
            }
        }
    </script>
  ```
  有时也需要在内联语句处理器中访问原始的 DOM 事件. 可以用特殊变量 `$event`
  把它传入方法中:
  ```vue
    <template>
        <div class="default-div">
            <h2>1.9.3: 内联处理器中的方法 + `$event`</h2>
            <p>
                <button @click="warn('Form cannot be submitted yet!', $event)">
                    Submit
                </button>
            </p>
            <p>{{ msg }}</p>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo193',
            data() {
                return {
                    msg: ''
                }
            },
            methods: {
                warn: function(message, event) {
                    // - 现在我们可以访问原生事件对象
                    if (event) {
                        event.preventDefault()
                    }
                    this.msg = message + ' ' + event.target.tagName;
                }
            }
        }
    </script>
  ```

##### 1.9.4 事件修饰符
- 在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()`
  是非常常见的需求. 尽管我们可以在方法中轻松实现这点, 但更好的方式是:
  方法只有纯粹的数据逻辑, 而不是去处理 DOM 事件细节.
    + **Added:** "DOM2 级事件" 定义了两个方法,
      用于处理指定和删除事件处理程序的操作: `addEventListener()` 和
      `removeEventListener()`. 所有 DOM 节点中都包含这两个方法,
      并且它们都接受 3 个参数:
        + (1) 要处理的事件名,
        + (2) 作为事件处理程序的函数和一个布尔值.
        + (3) 最后这个布尔值参数如果是 `true`,
          表示在"捕获阶段(capture)"调用事件处理程序; 如果是 `false`,
          表示在"冒泡阶段(bubble)"调用事件处理程序. 
          要在按钮上为 click 事件添加事件处理程序, 可以使用下列代码:
          ```js
            var btn = document.getElementById("myBtn");
            btn.addEventListener("click", function(){
                console.log(this.id);
            }, false);
          ```
    + **More:** 事件的详细讲解见: 《JavaScript高级程序设计》的 第 13 章.

  为了解决这个问题. Vue.js 为 `v-on` 提供了 **事件修饰符**. 之前提过,
  修饰符是由点开头的指令后缀来表示的.
    + `.stop`: 等于 `event.stopPropagation()` 取消事件的进一步捕获或冒泡.
    + `.prevent`:  等于 `event.preventDefault()` 取消事件的默认行为.
    + `.capture`: 添加事件监听时使用事件捕获模式.
        - "DOM2及事件" 规定的事件流包括 3 个阶段: `事件捕获阶段`,
          `处于目标阶段` 和 `事件冒泡阶段`. 更多信息见 <JS高程> 13.1.3.
    + `.self`: 只当 `event.target` 是当前元素自身时才会触发处理函数.
    + `.once`: 2.1.4 新增. 表示事件只触发一次. (Note: 详细可以见仓库:
      `JS-book-learning/《JavaScript高级程序设计》/Chapter13-事件/chapter13-事件.md`)
    + `.passive`: 解释见下面
- 我们来看下大致的使用方式:
  ```html
    <!-- 阻止单击事件继续传播 -->
    <a @click.stop="doThis"></a>

    <!-- 提交事件不再重载页面 -->
    <form @submit.prevent="onSubmit"></form>

    <!-- 修饰符可以串联 -->
    <a @click.stop.prevent="doThat"></a>

    <!-- 只有修修饰符 -->
    <form @submit.prevent></form>

    <!-- 添加事件监听器时使用事件捕获模式 -->
    <!-- 即内部元素触发的事件先在此处理, 然后才交由内部元素进行处理 -->
    <div @click.captue="doThis">...</div>
    
    <!-- 只当 event.target 是当前元素自身时触发处理函数 -->
    <!-- 即事件不是从内部元素触发的 -->
    <div @click.self="doThat">...</div>
  ```

  **注意:** 使用修饰符时, 顺序很重要; 相应的代码会以同样的顺序产生. 因此,
  用 `@click.prevent.self` 会组织**所有的点击**, 而 `@click.self.prevent`
  追回阻止对元素自身的点击.

  > 2.1.4 新增
  ```html
    <!-- 点击事件只会触发一次 -->
    <a @click.once="doThis"></a>
  ```
  不像其它只能对原生的 DOM 事件起作用的修饰符, `.once`
  修饰符还能被用到`自定义组件事件`(`../02-深入了解组件/2.3-自定义事件.md`)上.
  如果你还没有阅读关于组件的文档, 现在大可不必担心.

  > 2.3.0 新增

  Vue 还对 `addEventListener` 中的 `passive`
    [选项](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)
    提供了 `.passive` 修饰符.
    - Tip: `passive`值为 `Boolean`. 设置为 `true` 时, 表示 `listener`
      永远不会调用 `preventDefault()`.
  ```html
    <!-- 滚动事件的默认行为 (即滚动行为) 将会立即出发, 而不会等待 `onScroll`
      完成. 这其中包含 `event.preventDefault()` 的情况. -->
    <div @scroll.passive="onScroll">...</div>
  ```
  这个 `.passive` 修饰符尤其能够提升移动端的性能.
  
  **注意:** 不要把 `.passive` 和 `.prevent` 一起使用, 因为 `.prevent`
  将会被忽略, 同时浏览器可能会向你展示一个警告. 请记住, `.passive`
  会告诉浏览器你不想阻止事件的默认行为.

##### 1.9.5 按键修饰符
- 在监听键盘事件时, 我们经常需要检查详细的按键. Vue 允许为 `v-on`
  在监听键盘事件时添加按键修饰符:
  ```html
    <!-- 只有 `key` 是 `Enter` 时调用 `vm.submit()` -->
    <input @keyup.enter="submit">
  ```
- 1.9.5.1 `.exact` 修饰符
- 1.9.5.2 鼠标按钮修饰符

##### 1.9.6 系统修饰键

##### 1.9.7 为什么在 `HTML` 中监听事件?