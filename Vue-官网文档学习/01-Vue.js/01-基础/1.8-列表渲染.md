# 1.8 列表渲染

## 目录(Catalog)
- 1.8 列表渲染
    + 1.8.1 用 `v-for` 把一个数组对应为一组元素 
    + 1.8.2 在 `v-for` 里使用对象
    + 1.8.3 维护状态
    + 1.8.4 数组更新检测
        - 1.8.4.1 变异方法
        - 1.8.4.2 替换数组
        - 1.8.4.3 注意事项
    + 1.8.5 对象变更检测注意事项
    + 1.8.6 显示过滤/排序后的结果
    + 1.8.7 在 `v-for` 里使用值范围
    + 1.8.8 在 `<template>` 上使用 `v-for`
    + 1.8.9 `v-for` 与 `v-if` 一同使用
    + 1.8.10 在组件上使用 `v-for`

## 生词(New Words)


## 内容(Content)
### 1.8 列表渲染
##### 1.8.1 用 `v-for` 把一个数组对应为一组元素 
- 我们可以用 `v-for` 指令基于一个数组来渲染一个列表. `v-for` 指令需要使用
  `item in items` 形式的特殊语法, 其中 items 是源数据数组, 
  而 `item` 则是被迭代的数组元素的别名. 示例代码如下:
  ```vue
    <template>
        <div id="app181" class="default-div">
            <h2>1.8.1: 用 `v-for` 把一个数组对应为一组元素 </h2>
            <ul id='example-1'>
                <li v-for="(item, index) in items" :key="index">
                    {{ item.message }}
                </li>
            </ul>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo181',
            data() {
                return {
                    parentMessage: 'Parent',
                    items: [
                        {message: 'Foo'},
                        {message: 'Bar'},
                    ]
                }
            }
        }
    </script>
  ```
  在 `v-for` 块中, 我们可以访问所有父作用域的属性. `v-for` 还支持一个可选的第二个参数,
  即当前项的索引. 例如:
  ```vue
    <template>
        <div id="app181" class="default-div">
            <h2>1.8.1: 用 `v-for` 把一个数组对应为一组元素 </h2>
            <ul id='example-1'>
                <li v-for="(item, index) in items" :key="index">
                    {{ parentMessage }} - {{ index }} - {{ item.message }}
                </li>
            </ul>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo181',
            data() {
                return {
                    parentMessage: 'Parent',
                    items: [
                        {message: 'Foo'},
                        {message: 'Bar'},
                    ]
                }
            }
        }
    </script>
  ```
  你也可以用 `of` 替代 `in` 作为分隔符, 因为它更接近 JavaScript 迭代器的语法:
  ```html
    <div v-for='item of items'></div>
  ```
  
##### 1.8.2 在 `v-for` 里使用对象
- 你也可以用 `v-for` 来遍历一个对象的属性. 除了默认的 `value` 参数,
  还可以接受额外的两个参数: 第 2 个参数为属性名(键名); 第 3 个参数 `index`
  作为索引. 来看一个示例:
  ```vue
    <template>
        <div id="app182" class="default-div">
            <h2>1.8.2: 在 `v-for` 里使用对象</h2>
            <ul id='v-for-object' class="demo">
            <li v-for="(value, name, index) in object" :key="index">
                {{ index + 1 }}. {{ value }}
            </li>
            </ul>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo182',
            data() {
                return {
                    object: {
                        title: 'How to do lists in Vue',
                        author: 'Jane Doe',
                        publishedAt: '2016-04-10',
                    }
                }
            }
        }
    </script>
  ```
- 在遍历对象时, 会按 `Object.keys()` 的结果遍历, 但是不能保证渲染出的结果在不同的
  JavaScript 引擎下都是一致的.
##### 1.8.3 维护状态 (Maintaining State)
- 当 Vue 更新使用 `v-for` 渲染的元素列表时, 它默认使用 "就地更新" 的策略.
  如果数据项的顺序被改变, Vue 默认不会移动 DOM 元素来匹配更该后的数据项的顺序,
  而是就地更新每个元素, 并且确保更新的操作反映了应该在该特定索引处要呈现的内容.
  (tip: 这段内容中文文档翻译感觉不通顺, 所以略加修改.)

  这个默认的模式是高效的, 但是**只适用于不依赖子组件状态或临时 DOM 状态(例如:
  表单输入值) 的列表渲染输出.**

  为了给 Vue 一个提示, 以便它能跟踪每个节点的特性, 从而重用和重新排序现在元素,
  你需要为每项提供一个唯一的 `key` 属性:
  ```html
    <div v-for="item in items" v-bind:Key="item.id">
        <!-- 内容 -->
    </div>
  ```
  建议尽可能在使用 `v-for` 时提供 `key` attribute(特性), 除非遍历输出的 DOM
  内容非常简单, 或者是刻意依赖默认行为以获取性能上的提升.

  因为它是 Vue 识别节点的一个通用机制, `key` 并不仅与 `v-for` 特别关联.
  后面我们将在指南中看到, 它还具有其它用途.

  注: 不要使用对象或数组之类的非基本类型值作为 `v-for` 的 `key`.
  请用字符串或数值类型的值.

  更过 `key` attribute 的细节用法请移步至 `key`
  [的 API 文档](https://cn.vuejs.org/v2/api/#key).


##### 1.8.4 数组更新检测
- 1.8.4.1 变异方法(mutation method)
    + Vue 将被侦听的数组的变异方法进行了包裹, 所以它们将会触发试图更新.
      这些被包裹过的方法包括:
        - (1) `push()`
        - (2) `pop()`
        - (3) `shift()`
        - (4) `unshift()`
        - (5) `splice()`
        - (6) `sort()`
        - (7) `reverse()`
- 1.8.4.2 替换数组
    + 变异方法, 顾名思义, 会改变调用了这些方法的原始数组. 相比之下,
      也有非变异(non-mutating method) 方法, 例如 `filter()`, `concat()`
      和 `slice()`. 它们不会改变原始数组, 而**总是返回一个新数组**.
      当使用非变异方法时, 可以用新数组替换旧数组. 看下面这个示例:
      ```vue
        <template>
            <div id="app1842" class="default-div">
                <h2>1.8.4.2: 替换数组</h2>
                <ul id='v-for-object' class="demo">
                <li v-for="(value, index) in items" :key="index">
                    {{ index + 1}}. {{ value.message }}
                </li>
                </ul>
                <button @click="replacingAnArray">替换数组</button>
            </div>
        </template>
        <script>
            export default {
                name: 'Demo1842',
                data() {
                    return {
                        items: [
                            {message: 'Foo'},
                            {message: 'Bar'},
                        ]
                    }
                },
                methods: {
                    replacingAnArray: function() {
                        this.items = this.items.filter(function(item) {
                            return item.message.match(/Foo/);
                        })
                    }
                }
            }
        </script>
      ```
      你可认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表. 幸运的是, 事实并非如此.
      Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发时方法,
      所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作.
- 1.8.4.3 注意事项
    + 由于 JavaScript 的限制, Vue 不能检测以下数组的变动:
        - (1) 当你利用索引直接设置一个数组项时, 例如:
          `vm.items[indexOfItem] = newValue`.
        - (2) 当你修改数组的长度时, 例如:
          `vm.items.length = newLength`
        - 举个例子:
          ```html
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Vue.js study</title>
                <style type="text/css">
                    .container{
                        width:20rem;
                        height:10rem;
                        margin:5rem;
                        background:#00AA88;
                    }
                </style>
                <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
            </head>
            <body>
                <div class="container">
                    <ul id="my-ul">
                        <li v-for="(item, index) in items" :key="index+1">
                            {{ item}}
                        </li>
                    </ul>
                </div>

                <script type="text/javascript">
                    const vm = new Vue({
                        el: "#my-ul",
                        data: {
                            items: ['a', 'b', 'c']
                        }
                    });
                    vm.items[1] = 'x';      // 不是响应性的
                    vm.items.length = 2;    // 不是响应性的
                </script>
            </body>
            </html>
          ```
          为了解决第一类问题, 以下 2 种方式都可以实现和
          `vm.items[indexOfItem] = newVale` 相同的效果,
          同时也将在响应式系统内触发状态更新:
          ```js
            // Vue.set
            Vue.set(vm.items, indexOfItem, newValue)
          ````
          或
          ```js
            // Array.prototype.splice
            vm.items.splice(indexOfItem, 1, newValue)
          ```
          你也可以使用 `vm.$set` 实例方法, 该方法是全局方法 `Vue.set` 的另一个别名:
          ```js
            vm.$set(vm.items, indexOfItem, newValue)
          ```
          为了解决第二个类问题, 你可以使用 `splice`:
          ```js
            vm.items.splice(newLength)
          ```

##### 1.8.5 对象变更检测注意事项
- 还是由于 JavaScript 的限制, **Vue 不能检测对象属性的添加或删除**:
  ```js
    var vm = new Vue({
        data: {
            a: 1
        }
    })
    // `vm.a` 现在是响应式的

    vm.b = 2
    // `vm.b` 不是响应式的
  ```
  对于已经创建的实例, Vue 不允许动态添加**根级别**的响应式属性. 但是, 
  可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式属性. 
  例如, 对于:
  ```js
    var vm = new Vue({
        data: {
            userProfile: {
            name: 'Anika'
            }
        }
    })
  ```
  你可以添加一个新的 `age` 属性到嵌套的 `userProfile `对象:
  ```js
    Vue.set(vm.userProfile, 'age', 27)
  ```
  你还可以使用 `vm.$set` 实例方法, 它只是全局 `Vue.set` 的别名:
  ```js
    vm.$set(vm.userProfile, 'age', 27)
  ```
  有时你可能需要为已有对象赋值多个新属性, 比如使用 `Object.assign()` 或
  `_.extend()`. 在这种情况下, 你应该用两个对象的属性创建一个新的对象. 所以, 
  如果你想添加新的响应式属性, 不要像这样:
  ```js
    Object.assign(vm.userProfile, {
        age: 27,
        favoriteColor: 'Vue Green'
    })
  ```
  你应该这样做:
  ```js
    vm.userProfile = Object.assign({}, vm.userProfile, {
        age: 27,
        favoriteColor: 'Vue Green'
    })
  ```

##### 1.8.6 显示过滤/排序后的结果
- 有时, 我们想要显示一个数组经过过滤或排序后的版本, 而不实际改变或重置原始数据.
  在这种情况下, 可以创建一个计算属性, 来返回过滤或排序后的数组.
  例如: 
  ```vue
    <template>
        <div id="app1842" class="default-div">
            <h2>1.8.6: 显示过滤/排序后的结果</h2>
            <ul>
                <li v-for="(num, index) in evenNumbers" :key="index">
                    {{ num }}
                </li>
            </ul>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo186',
            data() {
                return {
                    numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9]
                }
            },
            computed: {
                evenNumbers: function() {
                    // - 返回偶数(even)项
                    return this.numbers.filter(function(number) {
                        return number % 2 === 0
                    })
                }
            }
        }
    </script>
  ```
  在计算属性不适用的情况下(例如: 在嵌套 `v-for` 循环中) 你可以使用一个方法. 例如:
  ```vue
    <template>
        <div id="app1842" class="default-div">
            <h2>1.8.6: 显示过滤/排序后的结果</h2>
            <ul>
                <li v-for="(num, index) in odd(numbers)" :key="index">
                    {{ num }}
                </li>
            </ul>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo186',
            data() {
                return {
                    numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9]
                }
            },
            methods: {
                odd: function(numbers) {
                    return numbers.filter(function(number) {
                        return number % 2 === 1
                    })
                }
            }
        }
    </script>
  ```

##### 1.8.7 在 `v-for` 里使用值范围
- `v-for` 也可以接受整数. 在这种情况下, 它会把模板重复对应次数. 例如
  ```html
    <div>
        <span v-for="num in 10" :key="num">
            {{ num }}
        </span>
    </div>
  ```
  结果: `1 2 3 4 5 6 7 8 9 10`

##### 1.8.8 在 `<template>` 上使用 `v-for`
- 上面很多示例都是使用 `template` 模板来书写的, 所以这里省略.

##### 1.8.9 `v-for` 与 `v-if` 一同使用
- 注意我们**不推荐**在同一元素上使用 `v-if` 和 `v-for`. 更多细节可查阅
  [风格指南](https://cn.vuejs.org/v2/style-guide/) 中
  "避免 v-if 和 v-for 用在一起" 以获得更多信息.

  当它们处于同一节点, `v-for` 的优先级比 `v-if` 更高, 这意味着 `v-if`
  将分别重复运行于每个 `v-for` 循环中. 当你只想要为 *部分项渲染节点* 时,
  这种优先级的机制会十分有用. 看如下代码:
  ```html
    <li v-for="todo in todos" v-if="!todo.isComplete">
        {{ todo }}
    </li>
  ```
  上面的代码只渲染未完成的 todo. 我们用 js 模拟一下上面代码的执行过程, 大致如下:
  ```js
    this.todos.map(function(todo) {
        if (!todo.isComplete) {
            return todo
        }
    })
  ```
  而如果你的目的是有条件地跳过循环的执行, 那么可以将 `v-if` 置于外层元素
  (或 `<template>`) 上. 如:
  ```html
    <ul v-if="todos.length">
        <li v-for="todo in todos">
            {{ todo }}
        </li>
    </ul>
    <p v-else>No todos left!</p>
  ```

##### 1.8.10 在组件上使用 `v-for`
- **注意**: 这部分内容假定你已经了解 `组件`(`./1.11-组件基础.md`) 相关知识. 
  你也完全可以先跳过它, 以后再回来查看.
  
  在自定义的组件上, 你可以像在任何普通元素上一样使用 `v-for`. 例如:
  ```html
    <my-component v-for="item in items" :key="item.id"></my-component>
  ```
  **注意:** 2.2.0+ 的版本里, 当在组件上使用 `v-for` 时, `key` 现在是必须的.

  然而, 任何数据都不会被自动传递到组件里, 因为组件有自己独立的作用域,
  为了把迭代数据传递到组件里, 我们要使用 `prop` (`./1.11-组件基础.md`):
  ```html
    <my-component 
        v-for="(item, index) in items"
        :item="item"
        :index="index"
        :key="item.id"
    ></my-component>
  ```
  不自动将 `item` 注入到组件里的原因是, 这会使的组件与 `v-for` 的运作紧密耦合.
  明确组件数据的来源能够使组件在其他场合重复使用.
- **I added:** 上面的讲解没懂没关系, 可以先跳过这一部分, 继续往下学习,把 基本
  部分的最后一节 `./1.11-组件基础.md` 学完就明白了,
  如果你像我一样已经使用过 单文件组件 了, 那就一起学习文档中给的:
  **简单的 todo 列表** 的完整例子吧.:
  
  示例见: `../../../vue-document-learning-example/src/components/1.8.10/todo-list.vue`.
