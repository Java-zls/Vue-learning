# 2.4 插槽


## 目录(Catalog)
- 2.4 插槽
    + 2.4.1 插槽内容
    + 2.4.2 编译作用域
    + 2.4.3 后备内容
    + 2.4.4 具名插槽
    + 2.4.5 作用域插槽
        - 2.4.5.1 独占默认插槽的缩写语法
        - 2.4.5.2 解构插槽 `Prop`
    + 2.4.6 动态插槽名
    + 2.4.7 具名插槽的缩写
    + 2.4.8 其他示例
    + 2.4.9 废弃了的语法
        - 2.4.9.1 带有 slot attribute 的具名插槽
        - 2.4.9.2 带有 slot-scope attribute 的作用域插槽


## 生词(New Words)




## 内容(Content)
> 该页面假设你已经阅读过了 `组件基础`(`../01-基础/1.11-组件基础.md`).
  如果你还对组件不太了解, 推荐你先阅读它. 

> 在 2.6.0 中, 我们为具名插槽(named slots)和作用域插槽(scoped slots)
  引入了一个新的统一的语法(即: `v-slot` 指令). 它取代了 `slot` 和 `slot-scope`
  这两个目前已经被废弃但未移除且仍在文档中的特性(attribute).
  新语法的由来可查看这份
  [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md)
### 2.4 插槽
##### 2.4.1 插槽内容
- Vue 实现了一套内容分发的 API, 这套 API 的设计灵感源自
  [Web Components 规范草案](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md),
  将 `<slot>` 元素作为承载分发内容的出口.

  它允许你像这样合成组件:
  ```html
    <navigation-link url="/profile">Your Profile</navigation-link>
  ```
  然后你在 `<navigation-link>` 的模板中可能会写到:
  ```html
    <a v-bind:href="url" class="nav-link">
        <slot></slot>
    </a>
  ```
  当组件渲染的时候, `<slot></slot>` 将会被替换为 `Your Profile`.
  插槽内可以包含任何模板代码, 包括 HTML: 
  ```html
    <navigation-link url="/profile">
        <!-- 添加一个 Font Awesome 图标 -->
        <span class="fa fa-user"></span>
        Your Profile
    </navigation-link>
  ```
  甚至其他的组件:
  ```html
    <navigation-link url="/profile">
        <!-- 添加一个图标的组件 -->
        <font-awesome-icon name="user"></font-awesome-icon>
        Your Profile
    </navigation-link>
  ```
  如果 `<navigation-link></navigation-link>` 的模板中没有包含一个 `<slot>`
  元素, 则该组件起始标签和结束标签之间的任何内容都会被抛弃.

##### 2.4.2 编译作用域
- 当你想在一个插槽中使用数据时, 例如:
  ```html
    <navigation-link url="/profile">
        Logged in as {{ user.name }}
    </navigation-link>
  ```
  该插槽跟模板的其他地方一样可以访问相同的实例属性(也就是相同的 "作用域"),
  而**不能**访问 `<navigation-link>` 的作用域. 例如 `url` 是访问不到的
  ```html
    <navigation-link url="/profile">
        Clicking here will send you to : {{ url }}
        <!-- 这里的 `url` 会是 undefined, 因为 "/profile" 是调用模板时,
          要传递给 <navigation-link> 组件的, 而不是在 <navigation-link>
          组件**内部**定义的. -->
    </navigation-link>
  ```
- 作为一条规则, 请记住:
    + > **父级模板里的所有内容都是在父级作用域中编译的;
      子模板里的所有内容都是在子作用域中编译的.**

##### 2.4.3 后备内容
- 有时为一个插槽(slot) 设置具体的后备(也就是默认的)内容是很有用的,
  它只会在没有提供内容的时候被渲染. 例如在一个 `<submit-button>` 组件中:
  ```html
    <button type="submit">
        <slot></slot>
    </button>
  ```
  我们可能希望这个 `<button>` 内绝大部分情况下都渲染文本 "Submit". 为了将
  "Submit" 作为后备内容, 我们可以将它放在 `<slot>` 标签内:
  ```html
    <button type="submit">
        <slot>Submit</slot>
    </button>
  ```
  现在当我们在一个父及组件中使用 `<submit-button>` 并且不提供任何插槽内容时,
  后备内容 "Submit" 将会被渲染:
  ```html
    <button type="submit"> Submit </button>
  ```
  
  但如果我们提供内容:
  ```html
    <submit-button>
        Save
    </submit-button>
  ```
  则这个提供的内容将会被渲染从而取代后备的内容:
  ```html
    <button type="submit">
        Save
    </button>
  ```


##### 2.4.4 具名插槽(named slots)
- > 自 2.6.0 起有所更新. 已废弃的使用 `slot` 特性(attribute) 的语法在
  "这里"(此文档下面的 `2.4.9 废弃的语法`)
- 有时我们需要多个插槽. 例如对于一个带有如下模板的 `<base-layout>` 组件:
  ```html
    <!-- /2.4.4/base-layout.vue -->
    <template>
        <div class="container">
            <header>
                <!-- 我们希望把页头放这里 -->
            </header>
            <main>
                <!-- 我们希望把主要内容放这里 -->
            </main>
            <footer>
                <!-- 我们希望把页脚放这里 -->
            </footer>
        </div>
    </template>
    <script>
        export default {
            name: 'BaseLayout',
            data() {
                return {

                }
            }
        }
    </script>
  ```
  对于这样的情况, `<slot>` 元素有一个特殊的特性 `name`. 这个 特性(attribute)
  可以用来定义额外的插槽. 修改上面的示例为:
  ```html
    <div>
        <header>
           <slot name="header"></slot>
       </header>
       <main>
           <slot></slot>
       </main>
       <footer>
           <slot name="footer"></slot>
       </footer>
   </div>
  ```
  一个不带 `name` 的 `<slot>` 默认会带有隐含的名字 "default" (即:
  `<slot name="default"></slot>`)

  在向具名插槽提供内容的时候, 我们可以在一个 `<template>` 元素上使用 `v-slot` 指令,
  并以 `v-slot` 的参数的形式提供其名称:
  ```html
    <template>
        <div id="Demo244" class="default-div">
            <h2>2.4.4 具名插槽(named slots)</h2>
            <base-layout>
                <!-- :header 为 v-slot 的参数 -->
                <template v-slot:header>
                    <h1>Here might be a page title</h1>
                </template>

                <p>A paragraph for the main content.</p>
                <p>And another one.</p>

                <template v-slot:footer>
                    <p>Here's some contact info</p>
                </template>
            </base-layout>
        </div>
    </template>
    <script>
        import BaseLayout from './base-layout';
        export default {
            name: 'Demo244',
            components: {
                BaseLayout,
            }
        }
    </script>
  ```
  现在 `<template>` 元素中的所有的内容都将会被传入相应的插槽. 任何没有被包裹在带有
  `v-slot` 的 `<template>` 中的内容都会被视为默认插槽的内容.

  然而, 如果你希望更明确一些, 仍然可以在一个 `<template>` 中包裹默认插槽的内容.
  即上面的代码可以改为:
  ```html
    <template v-slot:deafault>
        <p>A paragraph for the main content.</p>
        <p>And another one.</p>
    </template>
  ```
  任何一种写法都会渲染出:
  ```html
    <div class="container">
        <header>
            <h1>Here might be a page title</h1>
        </header>
        <main>
            <p>A paragraph for the main content.</p>
            <p>And another one.</p>
        </main>
        <footer>
            <p>Here's some contact info</p>
        </footer>
    </div>
  ```
  注意 `v-slot` **只能添加在 `<template>`** 上 (只有
  `一种例外情形`--`2.4.5.1 独占默认插槽的缩写语法`), 这一点和已经废弃的 `slot`
  特性不同.
  
  我们用一张图来说明:
  <img src="../vue-document-images/name-scoped.png"
    style="margin-left: 0; width: 100%;">


##### 2.4.5 作用域插槽
- > 自 2.6.0 起有所更新. 已废弃的使用 `slot-scope` 特性(attribute) 的语法在
  "这里"(此文档下面的 `2.4.9 废弃的语法`)
- 有时候让插槽内容能够访问子组件中才有的数据是很有用的. 例如, 设想一下带有如下模板的
  `<current-user>` 组件:
  ```html
    <span>
        <slot>{{ user.lastName }}</slot>
    </span>
  ```
  我们在父作用域中可能想换掉备用内容, 用名而非姓来显示. 如下:
  ```html
    <current-user>
        {{ user.firstName }}
    </current-user>
  ```
  然而上述代码不会正常工作, 因为只有 `<current-user>` 模板组件才可以访问到 `user`
  而我们提供的内容是在父级渲染的.

  为了让 `user` 在父级的插槽内容中可用, 我们可以将 `user` 作为 `<slot>`
  元素的一个特性绑定上去. 给出单文件组件的写法:
  ```vue
    <!-- current-user.vue -->
    <template>
        <div>
            <!-- 把 `user` 属性动态绑定到 `<slot>` 元素上. -->
            <!-- 绑定在 `slot` 元素上的特性被称为插槽 prop -->
            <slot v-bind:user="user">
                {{ user.lastName }}
            </slot>
        </div>
    </template>
    <script>
        export default {
            name: 'CurrentUser',
            data() {
                return {
                    user: {
                        firstName: 'Evan',
                        lastName: 'You'
                    }
                }
            }
        }
    </script>
  ```
  绑定在 `<slot>` 元素上的 特性(attribute) 被称为 **插槽 prop**.
  现在在父级作用域中, 我们可以使用带值的 `v-slot` 来定义我们提供的插槽 prop 的名字.
  示例代码:
  ```vue
    <template>
        <div id="Demo244" class="default-div">
            <h2>2.4.5 作用域插槽 (Scoped Slot)</h2>
            <current-user>
                <!-- 在父级作用域中, 使用带值的 `v-slot` 指令来定义提供的插槽 prop  -->
                <template v-slot:default="slotProps">
                    {{ slotProps.user.firstName }}
                </template>
            </current-user>
        </div>
    </template>
    <script>
        import CurrentUser from './current-user';
        export default {
            name: 'Demo245',
            components: {
                CurrentUser,
            }
        }
    </script>
  ```
  在这个例子中, 我们选择将包含所有插槽 prop 的对象命名为 `slotProps`,
  但你也可以使用任意你喜欢的名字.

  我们用一张图来说明:
  <img src="../vue-document-images/scoped-slots.png"
    style="margin-left: 0; width: 100%;">
  
  Notice: 注意这里的 `<template v-slot:default="slotProps">`
  和上面具名插槽的默认插槽 `<template v-slot:default>` 写法的区别.

- **2.4.5.1 独占默认插槽的缩写语法**
    + 上面的作用域插槽的情况下, 当被提供的内容只有 *默认* 插槽时,
      组件的标签才可以被当作插槽的模板来使用. 这样我们就可以把 `v-slot`
      直接用在组件上, 写法如下:
      ```html
        <!-- 和上面图中的写法一样 -->
        <current-user v-slot:default="slotProps">
            {{ slotProps.user.firstName }}
        </current-user>
      ```
      这种写法还可以更简单. 就像假定未指明的内容对应默认插槽一样, 不带参数的 `v-slot`
      被假定对应默认插槽:
      ```html
        <current-user v-slot="slotProps">
            {{ slotProps.user.firstName }}
        </current-user>
      ```
      注意默认插槽的缩写语法**不能**和具名插槽混用, 因为它会导致作用域不明确:
      ```html
        <current-user v-slot="slotProps">
            {{ slotProps.user.firstName }}
            <template v-slot:other="otherSlotProps">
                slotProps is NOT available here
            </template>
        </current-user>
      ```
      只要出现多个插槽, 请始终为所有的插槽使用完整的基于 `<template>` 的语法:
      ```html
        <current-user>
            <template v-slot:default="slotProps">
                {{ slotProps.user.firstName }}
            </template>

            <template v-slot:other="otherSlotProps">
                ...
            </template>    
        </current-user>
      ```
- **2.4.5.2 解构插槽 `Prop`**
    + 作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个参数的函数里:
      ```js
        function (slotProps) {
            // 插槽内容
        }
      ```
      这意味着 `v-slot` 的值实际上可以是任何能够作为函数参数的 JS 表达式.
      所以在支持的环境下(`单文件组件`(`../05-工具.md` 5.1 单文件组件)和
      `现代浏览器`(`https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9`))
      ,你也可以使用 `ES2015 解构`(tip: 更多讲解见仓库:
      `JS-book-learning/《深入理解ES6》/chapter05_解构/chapter05-解构.md`)
      来传入具体的插槽 prop. 如下:
      ```html
        <current-user v-slot="{ user }">
            {{ user.firstName }}
        </current-user>
      ```
      这样可以使模板更简洁, 尤其是在该插槽提供了多个 prop 的时候. 它同样开启了 prop
      重命名等其它可能, 例如 `user` 重命名为 `person`:
      ```html
        <current-user v-slot="{ user: person }">
            {{ person.firstName }}
        </current-user>
      ```
      你甚至可以定义后备内容, 用于插槽 prop 是 undefined 的情形:
      ```html
        <current-user v-slot="{ user = { firstName: 'Guest' } }">
            {{ user.firstName }}
        </current-user>
      ```

##### 2.4.6 动态插槽名
- > 2.6.0 新增
- `动态指令参数`(`../01-基础/1.4-模板语法.md` 1.4.2 指令) 也可以用在 `v-slot`
  上, 来定义动态的插槽名:
  ```html
    <base-layout>
        <template v-slot:[dynamicSlotName]>
            ...
        </template>
    </base-layout>
  ```

##### 2.4.7 具名插槽的缩写
- 跟 `v-on` 和 `v-bind` 一样, `v-slot` 也有缩写, 即把参数之前的所有内容
  (`v-slot:`) 替换为字符 `#`. <br/>
  例如: `v-slot:header` 可以重写为 `#header`:
  ```html
    <base-layout>
        <template #header>
            <h1>Here might be a page title</h1>
        </template>

        <template #default>
            <p>A paragraph for the main content.</p>
            <p>And another one.</p>
        </template>

        <template #footer>
            <p>Here's some contact info</p>
        </template>
    </base-layout>
  ```
  由于上面 2.4.5 作用域插槽中的语法只是使用带值的 `v-slot` 来接收子组件的插槽 prop,
  同理作用域插槽的 `v-slot` 也是可以缩写的; 那么把上面 2.4.5 中的示例 +
  2.4.5.2 结构插槽 `prop` + 此时的具名插槽的缩写, 此时的写法为:
  ```html
    <current-user #default="{ user }">
        {{ user.firstName }}
    </current-user>
  ```
  注意, 和其他指令一样, 该缩写只在其有参数的时候才可用. 这意味着下面的语法是无效的:
  ```html
    <current-user #="{ user }">
        {{ user.firstName }}
    </current-user>
  ```
  即, 如果你希望使用缩写的话, 必须始终明确插槽名. (e.g. `#default`).

##### 2.4.8 其他示例
- **插槽 prop**(上面 `2.4.5 作用域插槽`: 绑定在 `<slot>` 元素上的特性被称为
  **插槽 prop**. 在父级作用域中使用带值的 `v-slot`来定义提供的插槽 prop 的名字)
  **允许我们将插槽转换为可复用的模板, 这些模板可以基于输入的 prop 渲染出不同的内容**.
  这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的.

  例如, 我们要实现一个 `<todo-list>` 组件, 它是一个列表且包含布局和过滤逻辑: <br/>
  我们可以将每个 todo 作为父级组件的插槽, 以此通过父级组件对其进行控制, 然后将
  `todo` 作为一个插槽 prop 进行绑定:
  ```vue
    <template>
        <div id="todo-list">
            <ul>
                <li v-for="todo in filteredTodos" v-bind:key="todo.id">
                    <!-- 我们为每个 todo 准备了一个插槽, 将 todo
                         对象作为一个插槽 prop 传入. -->
                    <!-- 绑定在 `slot` 元素上的特性被称为插槽 prop -->
                    <slot name="todo" :todo="todo">
                        <!-- 后备内容 -->
                        {{ todo.text }}
                    </slot>
                </li>
            </ul>
        </div>
    </template>
    <script>
        export default {
            name: 'TodoList',
            props: {
                todos: {
                    type: Array,
                    required: true
                }
            },
            computed: {
                filteredTodos: function() {
                    return this.todos.filter(function(item) {
                        return item.isComplete
                    });
                }
            }

        }
    </script>
  ```
  现在当我们使用 `<todo-list>` 组件的时候, 我们可以选择为 todo 定义一个不一样的
  `<template>` 作为替代方案, 并且可以从子组件获取数据:
  ```vue
    <template>
        <div id="Demo248" class="default-div">
            <h2>2.4.8 其它示例 -- TodoList</h2>
            <!-- v-bind:todos 我当前组件传给todo-list 的 prop -->
            <todo-list :todos="todos">
                <!-- v-slot:todo为接收子组件的插槽 prop -->
                <template v-slot:todo="{ todo }">
                    <span v-if="todo.isComplete">✓</span>
                    {{ todo.text }}
                </template>
            </todo-list>
        </div>
    </template>
    <script>
        import TodoList from "./todo-list";
        export default {
            name: 'Demo248',
            data() {
                return {
                    todos: [
                        {id:1, text: 'Do the dishes', isComplete: true},
                        {id:2, text: 'Take out the trash', isComplete: true},
                        {id:3, text: 'Mow the lawn', isComplete: false},
                    ],
                }
            },
            components: {
                TodoList
            }
        }
    </script>
  ```
  这只是作用域插槽用武之地的冰山一角. 想了解更多现实生活中的作用域插槽的用法,
  我们推荐浏览诸如
  [Vue Virtual Scroller](https://github.com/Akryum/vue-virtual-scroller),
  [Vue Promised](https://github.com/posva/vue-promised)
  和 [Portal Vue](https://github.com/LinusBorg/portal-vue) 等库.
  

##### 2.4.9 废弃了的语法
- **2.4.9.1 带有 slot attribute 的具名插槽**
    + 略
- **2.4.9.2 带有 slot-scope attribute 的作用域插槽**
    + 略