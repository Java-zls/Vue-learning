# 2.5 动态组件和异步组件

## 目录(Catalog)
- 2.5 动态组件 & 异步组件
    + 2.5.1 在动态组件上使用 `keep-alive`
    + 2.5.2 异步组件
        - 2.5.2.1 处理加载状态


## 生词(New Words)
- **tab [tæb] --n.标签; 账单; 制表**
    + The first tab is appended at this time. 第一个标签页是在这个时候加载的.
    + Quick Tab. 快速标签.
- **post [post] --n.邮件; 职位; 柱子; 标杆. --v.邮寄; 公布; 张贴. --vi.快速行进**
    + tab posts. 标签页
    + The post(n) hasn't come yet. 邮件还没来.
    + I had a heavy post(n) yesterday. 我昨天收到很多邮件.
    + the Sunday Post(n). 星期日邮报.
    + I posted(vt) him a Christmas card. 我寄给他一张圣诞卡.


## 内容(Content)
> 该页面假设你已经阅读过了 `组件基础`(`../01-基础/1.11-组件基础.md`).
  如果你还对组件不太了解, 推荐你先阅读它. 
### 2.5 动态组件 & 异步组件
##### 2.5.1 在动态组件上使用 `keep-alive`
- 我们之前曾在一个多标签的界面中使用 `is` 特性来切换不同的组件(即:
  `1.11.8 动态组件`). 现在稍微更该代码来实现下面这个效果:
  ```vue
    <!-- 2.5.1.vue -->
    <template>
        <div id="Demo251" class="default-div">
            <h2>2.5.1 在动态组件上使用 keep-alive</h2>
            <button
                v-for="tab in tabs"
                :key="tab"
                @click="currentTab = tab"
                :class="['tab-button', {active: currentTab === tab}]"
            >
                {{ tab }}
            </button>
            <component :is="currentTabComponent" class="tab"></component>
        </div>
    </template>
    <script>
        import TabPosts from './tab-posts';
        import TabArchive from './tab-archive';
        export default {
            name: 'Demo251',
            data() {
                return {
                    currentTab: 'Posts',
                    tabs: ["Posts", "Archive"]
                }
            },
            components: {
                TabPosts,
                TabArchive,
            },
            computed: {
                currentTabComponent: function() {
                    return 'tab-' + this.currentTab.toLowerCase()
                }
            }
        }
    </script>
    <style scoped>
        #Demo251 {
            min-width: 660px;
            min-height: 200px;
        }
        .tab-button {
            padding: 6px 10px;
            border-top-left-radius: 3px;
            border-top-right-radius: 3px;
            border: 1px solid #ccc;
            cursor: pointer;
            background: #f0f0f0;
            margin-bottom: -1px;
            margin-right: -1px;
        }
        .tab-button:hover {
            background: #e0e0e0;
        }
        .current-tab {
            color: #f54343;
        }
        .tab-button.active {
            background: #e0e0e0;
        }
        .tab {
            border: 1px solid #ccc;
            padding: 10px;
        }
    </style>
  ```
  ```vue
    <!-- tab-posts.vue -->
    <template>
        <div id="tab-posts">
            <ul class="article-title">
                <!-- 如果 post === selectedPost 那么添加 selected 样式 -->
                <li
                    v-for="(post, index) in posts"
                    :key="index"
                    @click="selectedPost = post"
                    :class="{selected: post === selectedPost}"
                >
                    {{ post.title }}
                </li>
            </ul>
            <div class="article-content">
                <div v-if="selectedPost" class="selected-post">
                    <h3>{{ selectedPost.title }}</h3>
                    <div v-html="selectedPost.content"></div>
                </div>
                <strong v-else>
                    Click on a blog title to the left to view it.
                </strong>
            </div>
        </div>
    </template>
    <script>
        export default {
            name:'TabPosts',
            data() {
                return {
                    posts: [
                        {
                            id: 1,
                            title: 'Cat Ipsum',
                            content: '<p>Dont wait for the storm to pass, ' +
                                'dance in the rain kick up litter decide to want nothing to do with' +
                                ' my owner today demand to be let outside at once.</p>'
                        },
                        {
                            id: 2,
                            title: 'Hipster Ipsum',
                            content: '<p>Bushwick blue bottle scenester helvetica ugh.</p>'
                        },
                        {
                            id: 3,
                            title: 'Cupcake Ipsum',
                            content: '<p>Icing dessert soufflé lollipop chocolate bar' +
                                'sweet tart cake chupa chups.</p>'
                        }
                    ],
                    selectedPost: null,
                }
            }
        }
    </script>
    <style scoped>
        #tab-posts {
            padding: 10px;
            display: flex;
            justify-content: flex-start;
            align-items: stretch;
        }
        .article-title {
            padding-right: 10px;
        }
        .article-title li {
            line-height: 26px;
            cursor: pointer;
            white-space: nowrap;
            padding: 0 5px 0 5px;
        }
        .article-title li.hover {
            background: #eee;
        }
        .article-title li.selected {
            background: lightgray;
        }

        .article-content {
            padding-left: 10px;
            border-left: 1px solid #ccc;
        }
    </style>
  ```
  ```vue
    <!-- tab-archive.vue -->
    <template>
        <div id="tab-archive">
            Archive component
        </div>
    </template>
    <script>
        export default {
            name:'TabArchive',
        }
    </script>
  ```
  运行效果可以启动 `../../../vue-document-learning-example/` 项目后自行查看,
  截图如下:
  <img src="../vue-document-images/2.5.1.png">

  **I added:** 此处说明一下 `tab-posts.vue` (标签页)组件, 这个单文件组件中是用
  Vue 实现选项卡切换, 简单梳理一下实现步骤:
    + (1) 使用 `v-for` 循环出 `li` 列表
    + (2) 绑定 `click` 事件, 事件触发时把 `posts` 数组中的当前点击项(即: `post`)
      赋值给 `selectedPost`.
    + (3) 经过第 2 步, `selectedPost` 的值发生改变, 因为 `data`
      中的数据都是双向绑定的, 所以 Vue 在后台会自动触发其他 DOM 元素中对
      `selectedPost` 的依赖, 这样 `v-if` 会自动执行, 此时 `selectedPost`
      已经有值了, 所以 `v-if` 对应的 DOM 便会展示, `v-show` 执行对应的 DOM
      会在再次编译时移除. 这样就实现了选项卡的切换. 
  
  你会注意到, 如果你选择了一篇文章, 切换到 `Archive` 标签, 然后再切换回 Posts,
  是不会继续展示你之前选择的文章的. 这是因为你每次切换新标签的时候, Vue
  都创建了一个新的 `currentTabComponent` 实例.

  重新创建动态组件的行为通常是非常有用的, 但是在这个案例中,
  我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来. 为了解决这个问题,
  我们可以用一个 `<keep-alive>` 元素将其动态组件包裹起来. 如下:
  ```html
    <!-- 失活的组件将会被缓存! -->
    <keep-alive>
        <component v-bind:is="currentTabComponent"></component>
    </keep-alive>
  ```

##### 2.5.2 异步组件
- **Added: 前置知识**
  [参考文章](https://juejin.im/post/5d52c1bce51d4562043f56de)
    + 异步组件是什么?
        - 异步是相对于同步而言的. 我们在使用 Vue 时, 使用到的组件大多为同步组件.
          在 Vue 实例第一次执行渲染的过程中, 已经生成了组件构造器.
          而异步组件则是在用到该组件时, 异步通过请求拉取对应组件的 JavaScript
          (这里需要和 Webpack 的 `import` 相结合). 当对应的 JS 加载完毕后,
          获取到异步组件的配置项, 从而创建组件构造器. 在通过 `foreRender`,
          强制依赖它的 vm 实例重新触发渲染函数.
    + 为什么需要异步组件?
        - 比如, 我们有一个后台管理系统, 通常左侧有一系列的操作 tab. 而每个 tab
          对应一个组件. 当用户进入时, 如果把所有的组件都进行加载, 会导致用户体验下降,
          等待时间过程. 所以就需要使用异步组件.
    + 异步组件如何使用?
        - 注册异步组件与注册普通组件差不多. 既可以全局注册, 也可以局部注册.
          不过不同的是异步组件需要通过 webpack 的 import 函数来引入. 例如:
          ```js
            // - 局部注册
            new Vue({
                // ...,
                components: {
                    a: () => import('./components/a.vue')
                }
            })

            // - 全局注册
            Vue.component('async-comp', (resolve, reject) => ({
                component: () => import('./component/a.vue'),
                loading: loadingComp,
                error: errorComp,
                delay: 200,
                timeout: 3000
            }))
          ```
          其中, 异步组件还有高级异步组件. 所谓高级异步组件, 就是提供了 loading
          组件(用于组件异步加载时展示), error组件(用于组件加载出错时展示),
          delay(用于延迟加载异步组件), timeout(用于设置异步组件加载的最大时长,
          如果超过了规定的时间还没有加载完毕, 则展示 error 组件).

          其中, error 和 loading 组件都是同步的. 因为当异步组件加载中或者加载出错时,
          需要立即展示对应的状态组件.

          对于异步组件, 通过使用 Webpack 提供的 import 函数, 可以让 Webpack
          在打包时将 import 中传入的组件文件单独打包. 这样当使用到该组件时,
          通过发送请求异步加载组件的 js, 当资源加载完毕后交给 Vue 来处理加载.
- 在大型应用中, 我们可能需要将应用分隔成小一些的代码块,
  并且只在需要的时候才从服务器加载一个模块. 为了简化, Vue
  允许你以一个工厂函数的方式定义你的组件, 这个工厂函数会异步解析你的组件定义.
  Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数, 且会把结果缓存起来供未来重渲染.
  例如:
  ```js
    Vue.component('async-example', function(resolve, reject) {
        setTimeout(function() {
            // - 向 `resolve` 回调传递组件定义
            resolve({
                template: `<div>I am async!</div>`
            })
        }, 1000)
    })
  ```
  如你所见, 这个工厂函数会收到一个 `resolve` 回调,
  这个回调函数会在你从服务器得到组件定义的时候被调用. 你也可以调用 `reject(reason)`
  来表示加载失败. 这里的 `setTimeout` 是为了演示用的, 如何获取组件取决于你自己.
  一个推荐的做法是将一部组件和
  [Webpack 的 code-spliting 功能](https://webpack.js.org/guides/code-splitting/)
  一起配合使用:
  ```js
    Vue.component('async-webpack-examle', function(resolve){
        // 这一个特殊的 `require` 语法将会告诉 webpack
        // 自动将你的构建代码切割成多包, 这些包会通过 Ajax 请求加载
        require(['./my-async-component'], resolve)
    })
  ```
  你也可以在工厂函数中返回一个 `Promise`, 所以把 webpack 2 和 ES2015 语法加在一起,
  我们可以写成这样:
  ```js
    Vue.component(
        'async-webpack-example', 
        // - 这个 `import` 函数会返回一个 `Promise` 对象
        () => import('./my-async-component')
    )
  ```
  当使用`局部注册`(`2.1.3 局部注册`)的时候, 你也可以直接提供一个返回 `Promise` 的函数:
  ```js
    new Vue({
        // ...
        components: {
            'my-component': () => require('./my-async-component')
        }
    })
  ```
  **Warning:** 如果你是一个 Browserify 用户同时喜欢使用异步组件,
  很不幸这个工具的作者
  [明确表示](https://github.com/browserify/browserify/issues/58#issuecomment-21978224)
  异步加载“并不会被 Browserify 支持”, 至少官方不会.Browserify 社区已经找到了
  [一些变通方案](https://github.com/vuejs/vuejs.org/issues/620),
  这些方案可能会对已存在的复杂应用有帮助. 对于其它的场景,
  我们推荐直接使用 webpack, 以拥有内置的头等异步支持. 
- **2.5.2.1 处理加载状态**
    + > 2.3.0+ 新增
    + 这里的异步组件工厂函数也可以返回一个如下格式的对象:
      ```js
        const AsyncComponent = () => ({
            // - 需要加载的组件 (应该是一个 `Promise` 对象)
            component: import('/MyComponent.vue`),
            // - 异步组件加载时使用的组件
            loading: LoadingComponent,
            // - 加载失败时使用的组件
            error: ErrorComponent,
            // - 展示加载组时组件的延时时间. 默认值是 200(毫秒)
            delay: 200,
            // - 如果提供了超时时间且组件加载也超时了, 则使用加载失败时使用的组件.
            //   默认值是 `Infinity`
            timeout: 3000
        })
      ```
    + **注意如果你希望在 [Vue Router](https://github.com/vuejs/vue-router)
      的路由组件中使用上述语法的话, 你必须使用 Vue Router 2.4.0+ 版本.**