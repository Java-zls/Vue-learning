# 1.5 计算属性和侦听器

## 目录(Catalog)
- 1.5 `计算属性`和`侦听器` (`Computed Properties` and `Watchers`)
    + 1.5.1 计算属性
        - 1.5.1.1 基础例子
        - 1.5.1.2 计算属性缓存 vs 方法
        - 1.5.1.3 计算属性 vs 侦听属性
        - 1.5.1.4 计算属性的 setter
    + 1.5.2 侦听器


## 生词(New Words)
- **reverse [rɪ'vɜːs] --adj.相反的. --v.逆转, 颠倒. --n.相反, 背面**
    + Reverse Proxy 反向代理, 逆向代理
    + We should see the reverse as well as the obverse of things.
        我们应该看到事物的反面和正面. 
- **obverse ['ɒbvɜːs]  --n.表面; 正面,前面. --adj.表面的; 正面的**
    + We should see the reverse as well as the obverse of things. 
      我们不但应该看到事物的正面, 也要看到事物的反面. 
- **as well as  --也；除...之外；不仅...而且**
    + He called on you as well as me. 他不仅拜访了我, 也拜访了你. 
    + He is a friend in word as well as in deed
        ([diːd] --n.行动, 功绩, 证书). 他是个言行如一的朋友. 
- **throttle ['θrɒt(ə)l] --n.节流(阀); 喉咙; 风门.**
- **debounce [di'bauns] --n.防抖**


## 内容(Content)
### 1.5 `计算属性`和`侦听器` (`Computed Properties` and `Watchers`)
- Hint: 计算属性(Computed properties) 是 Vue 中的自定义属性, 但实际上我们知道,
  JS 语法都是根据 ECMAScript 规范定义的, 在 ES5 中只定义 2 种属性: `数据属性` 和
  `访问器属性`; 那么 Vue 此处的计算属性是哪种属性的封装? 答案很明显,
  那就是 `访问器属性`, 因为 Vue 是个响应式的框架, 数据默认都是响应的,
  在 ES6 之前, JS 中定义响应式数据, 就只能使用 `Object.defineProperty()` 方法,
  而这个方法在内部实现响应式的原理就是需要定义 `getter` 和 `setter` 函数
  (tip: 不过 <JS高程> 上说这两个函数都不是必须的.), 在接下来的文档代码里, 你会看到
   `计算属性的 getter` 这种字眼, 那时你就不会迷茫了.
   (更多信息见: 《JavaScript高级程序设计》的第 6 章 -- 面向对象的程序设计.)
##### 1.5.1 `计算属性 (Computed Properties)`
- 模板内的表达式非常便利, 但是设计它们的初衷是用于简单运算的.
  在模板中放入太多的逻辑会让模板过重且难以维护. 例如：
  ```html
    <div id="example">
        {{ message.split('').reverse().join('') }}
    </div>
  ```
  在这个地方, 模板不再是简单的声明式逻辑. 你必须看一段时间才能意识到,
  这里是想要显示变量 message 的翻转字符串. 当你想要在模板中多次引用此处的翻转字符串时,
  就会更加难以处理. 所以, 对于任何复杂逻辑, 你都应当使用计算属性. 
- 1.5.1.1 基础例子
    + 示例见: `../../../vue-document-learning-example/src/components/1.5.1.1.vue`,
      (Tip: 记得不要忘记把 `1.5.1.1.vue` 在 `App.vue` 中 `import`)
      ```vue
        <template>
            <div id="app-1511" class="default-div">
                <h2>1.5.1.1 计算属性-基础示例</h2>
                <div id="example">
                    <!-- Tip: 从下面的 JS 代码中可以看到 `reversedMessage`
                    是一个方法属性, 但是在当前模板中, 如果不给 `reversedMessage`
                    传递参数, 不需要在其后添加 `()`, Vue 源码内部会帮我们做处理,
                    我想这样是 Vue 称呼其名叫 `计算属性` 属性的原因,
                    传递参数的写法见, 见下个 `p` 标签.-->
                    <p>Original message: "{{ message }}"</p>
                    <p>Passing parameters to Computed Properties:
                        {{ passPar(666)}}
                    </p>
                    <p>Computed reversed message: "{{ reversedMsg() }}"</p>
                </div>
            </div>
        </template>

        <script>
            export default {
                name: 'Demo1511',
                data() {
                    return {
                        message: 'Hello'
                    }
                },
                computed: {
                    // - 计算属性的 getter
                    reversedMessage: function() {
                        // - this 执行 vm 实例
                        // - String.split(): 基于指定的分隔符, 把字符串转换为数组
                        return this.message.split('').reverse().join('')
                    },
                    passPar() {
                        return function(num) {
                            return num;
                        }
                    }
                },
                methods: {
                    reversedMsg: function() {
                        return this.message.split('').reverse().join('')
                    }
                }
            }
        </script>

      ```
      这里我们声明了一个计算属性 `reversedMessage`, 我们提供的函数将用作属性
      `vm.reversedMessage` 的 `getter` 函数.
      你可以像绑定普通属性一样在模板中绑定计算属性. Vue 知道 `vm.reversedMessage`
      依赖于 `vm.message`, 因此当 `vm.message` 发生改变时, 所有依赖 `vm.reversedMessage` 的绑定也会更新.
      而且最妙的是我们已经以声明的方式创建了这种依赖关系: 计算属性的 `getter`
      函数是没有副作用 (`side effect`) 的, 这使它更易于测试和理解. 
- 1.5.1.2 计算属性缓存 vs 方法(`methods`)
    + 我们可以通过在表达式中调用方法来达到同样的效果. 示例仍然见: 
      `../../../vue-document-learning-example/src/components/1.5.1.1.vue`
      ```vue
        <!-- 示例 `1.5.1.1.vue` 中的部分代码: -->
        <template>
            <div id="app-1511" class="default-div">
                <h2>1.5.1.1 计算属性-基础示例</h2>
                <div id="example">
                    <p>Computed reversed message: "{{ reversedMsg() }}"</p>
                </div>
            </div>
        </template>

        <script>
            export default {
            
                // 省略....

                methods: {
                    reversedMessage: function() {
                        return this.message.split('').reverse().join('')
                    }
                }
            } 
        </script>
      ```
      我们可以将同一函数定义为一个方法或者是一个计算属性.
      两种方式的最终结果确实是完全相同的(tip: 模板中的调用略有不同).
      那么这 2 种方式有什么区别呢? 答: 区别是:
      **计算属性是基于它们的响应式依赖进行缓存的,**
      只有它们的相关响应式依赖发生改变它们才会重新求值. 对应上面的示例就是,
      如果 `data` 内的 `message` 不发生改变, 那么 `computed` 属性内的
      `reversedMessage` 属性方法就不会重新求值; 不管我们访问多少次
      `reversedMessage` 计算属性, 它都会立即返回之前的计算结果, 而不必再次执行函数.

      这样就意味着下面的计算属性将不会更新, 因为 `Date.now` 不是响应式依赖:
      ```js
        computed: {
            now: function() {
                return Date.now()
            }
        }
      ```

      相比之下, 每当触发重新渲染时, 调用方法 (methods) **总是**会字词执行函数. 

      我们为什么需要缓存? 假设我们有一个性能开销比较大的计算属性 A,
      它需要遍历一个巨大的数组并做大量的计算. 然后我们可能有其他的计算属性依赖于 A.
      如果没有缓存, 我们将不可避免的多次执行 A 的 getter!. 如果你不希望有缓存,
      请用方法来替代. 

- 1.5.1.3 计算属性(`Computed`) vs 侦听属性(`Watched Property`)
    + Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动: **侦听属性**.
      当你有一些数据需要随着其他数据变动而变动时, 你很容易滥用 `watch` --
      特别是如果你之前使用过 AngularJS. 然而更好的做法是使用计算属性而不是命令式的
      `watch` 回调. 细想下面这个例子.

      示例见: `../../../vue-document-learning-example/src/components/1.5.1.3.vue`
      ```vue
        <template>
            <div id="app-1513" class="default-div">
                <h2>1.5.1.3: 计算属性 vs 侦听属性</h2>
                <p id="demo">{{ firstName }} {{ lastName }} </p>
            </div>
        </template>

        <script>
            export default {
                name: 'Demo1513',
                data() {
                    return {
                        firstName: 'Foo',
                        lastName: 'Bar',
                        fullName: '',
                    }
                },
                watch: {
                    firstName: function(val) {
                        this.fullName = val + ' ' + this.lastName
                    },
                    lastName: function(val) {
                        this.fullName = this.first + ' ' + val
                    }
                }
            }
        </script>
      ```
      上面代码是命令式且重复的. 现在将它与计算属性的版本进行比较:
      ```vue
        <template>
            <div id="app-1513" class="default-div">
                <h2>1.5.1.3: 计算属性 vs 侦听属性</h2>
                <p>{{ fullName }}</p>
            </div>
        </template>

        <script>
            export default {
                name: 'Demo1513',
                data() {
                    return {
                        firstName: 'Foo',
                        lastName: 'Bar',
                    }
                },
                computed: {
                    fullName: function() {
                        return this.firstName + ' ' + this.lastName
                    }
                },
            }
        </script>
      ```

- 1.5.1.4 计算属性的 `setter`
    + 计算属性默认只有 `getter`, 不过在需要时你也可以提供一个 `setter`: 
      
      示例见: `../../../vue-document-learning-example/src/components/1.5.1.4.vue`;
      ```vue
        <template>
            <div id="app-1514" class="default-div">
                <h2>1.5.1.4: 计算属性的 setter</h2>
                <p><input v-model="fullName" placeholder="请输入一个姓名"></p>
                <p>{{ fullName }}</p>
            </div>
        </template>

        <script>
            export default {
                name: 'Demo1514',
                data() {
                    return {
                        name: 'Evan You'
                    }
                },
                computed: {
                    fullName: {
                        // - getter
                        get: function() {
                            return this.name;
                        },
                        // - setter
                        set: function(newName) {
                            this.name = newName;
                        }
                    }
                },
            }
        </script>
      ```
##### 1.5.2 侦听器(`Watchers`)
- 虽然`计算属性`在大多数情况下更合适, 但有时也需要一个自定义的侦听器. 这就是为什么 Vue
  通过 `watch` 选项提供了一个更通用的方法来响应数据的变化.
  当需要在数据变化时执行异步或开销较大的操作时, 这个方式是最有用的.
- Added: 由于我们的示例是使用 `Vue CLI` 生成的模板项目, 默认并没有安装 `axios`
  和 `lodash` 下面这个示例需要使用这两个插件, 所以现在
  `../../../vue-document-learning-example` 项目中利用 `npm` 来安装.
  ```shell
    # 安装 axios
    npm install axios

    # 安装 lodash
    npm instll loash
  ```
- 接着我们在 `1.5.2.vue` 中分别引入这两个插件. 下面是详细代码:
  ```vue
    <template>
        <div id="app152" class="default-div">
            <h2>1.5.2: 侦听器(Watchers)</h2>
            <div id="watch-example">
                <p>
                    Ask a yes/no question:
                    <input v-model="question">
                </p>
                <p>{{ answer }}</p>
            </div>
        </div>
    </template>

    <script>
        // - 使用 ES6 的方式引入 axios 和 lodash.
        // - 注意: 下面都是用的 `_` 来表示的 lodash.
        import axios from 'axios';
        import _ from 'lodash';

        export default {
            name: 'Demo152',
            data() {
                return {
                    question: '',
                    answer: 'I cannot give you an answer until you ask a question!'
                }
            },
            watch: {
                // - 如果 `question` 发生改变, 这个函数就会运行
                question: function(newQuestion, oldQuestion) {
                    console.log('newQuestion:', newQuestion);
                    console.log('oldQuestion', oldQuestion);
                    this.answer = 'Waiting for you to stop typing...';
                    this.debouncedGetAnswer()
                }
            },
            created: function() {
                // - `_.debounce` 是一个通过 Lodash 限制操作频率的函数. 在这个例子中,
                //   我们希望限制访问 yesno.wtf/api 的频率; AJAX 请求直到用户输入完毕
                //   才会发现. 想要了解更多关于 `_.debounce` 函数
                //   (及其近亲 `_.throttle`) 的知识,
                //   请参考: https://lodash.com/docs#debounce

                // - 函数节流和函数防抖的简单参考:
                //   `/js-sundry-goods/20190224-函数节流和防抖/函数节流和防抖.md`
                this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
            },
            methods: {
                getAnswer: function() {
                    if (this.question.indexOf('?') === -1) {
                        this.answer =
                            'Questions usually contain a question mark. ;-)';
                        return;
                    }
                    this.answer = 'Thinking...';
                    let vm = this;
                    axios.get('https://yesno.wtf/api')
                        .then(function(response) {
                            vm.answer = _.capitalize(response.data.answer)
                        })
                        .catch(function(error) {
                            vm.answer = 'Error! Could not reach the API. ' + error;
                        })
                }
            }
        }
    </script>
  ```
  在这个示例中, `watch` 选项允许我们执行异步操作(访问一个 API),
  限制我们执行该操作的频率, 并在我们得到最终结果前, 设置中间状态,
  这些都是计算属性无法做到的.
    + Notice: `watch` 属性内的 `question` 方法名是和 `data` 中的 `question`
      属性相对应的; `create()` 方法内可以直接通过 `this.getAnswer` 访问 `methods`
      的原因是 Vue 在源码中做了处理, 具体的源码实现, 将来会在本仓库的
      `../../../《Vue技术内幕-逐行级别的Vue源码分析》` 中做讲解.

  除了 `watch` 选项之外, 你还可以使用命令式的
  [vm.$watch API](https://cn.vuejs.org/v2/api/#vm-watch)


