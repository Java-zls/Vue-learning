# 1.9 事件处理

## 目录(Catalog)
- 1.9 事件处理
    + 1.9.1 监听事件 
    + 1.9.2 事件处理方法
    + 1.9.3 内联处理器中的方法
    + 1.9.4 事件修饰符
    + 1.9.5 按键修饰符
        - 19.5.1 按键码
    + 1.9.6 系统修饰键
        - 1.9.6.1 `.exact` 修饰符
        - 1.9.6.2 鼠标按钮修饰符
    + 1.9.7 为什么在 `HTML` 中监听事件?

## 生词(New Words)
- **prevent [pri'vɛnt] --vt.防止; 预防; 阻止; 避免;**
    + prevent progress. 妨碍进步[进行].
    + prevent traffic accidents. 防止交通事故.
    + We prevented the fire from spreading. 我们阻止火势蔓延.
    + I was prevented from attending by a cold. 感冒使得我不能出席.
    + Business prevented his going = Business prevented him going.
      他因有事而不能去.
- **propagation [ˌprɒpə'ɡeɪʃən] --n.传播; 繁殖;**
    + the propagation of the principles of science. 科学原理的传播.
- **passive ['pæsɪv] --adj.被动的, 消极的, 被动语态的.  --n.被动语态**
    + passive DNS. 被动 DNS
    + passive smoking 被动吸烟; 吸二手烟
    + We should translate this sentence in passive voice.
      我们应该用被动语态翻译这个句子.
- **exact [ɪg'zækt] --adj.精确的, 确切的**
    + Do you have any idea of the exact date? 你知道具体是在哪一天吗？
    + See `npm help json` for definitive documentation on these fields
      and exactly what they do.
      请参阅 `npm help json` 以获取有关这些字段的权威文档及其确切功能.
      


## 内容(Content)
### 1.9 事件处理
##### 1.9.1 监听事件 
- 可以用 `v-on` 指令监听 DOM 事件, 并在触发时运行一些 JavaScript 代码.示例:
  ```vue
    <template>
        <div id="app191" class="default-div">
            <h2>1.9.1: 监听事件</h2>
            <div id="example-1">
                <button @click="counter += 1">Add 1</button>
                <p>The button above has been clicked {{ counter }} times.</p>
            </div>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo191',
            data() {
                return {
                    counter: 0
                }
            }
        }
    </script>
  ```

##### 1.9.2 事件处理方法
- 然而许多事件处理逻辑会更为复杂, 所以直接把 JavasScript 代码写在 `v-on`
  指令中是不可行的. 因此 `v-on` 还可以接收一个需要调用的方法名称. 示例如下:
  ```vue
    <template>
        <div id="app192" class="default-div">
            <h2>1.9.2: 事件处理方法</h2>
            <div id="example-2">
                <!-- `greet` 是下面定义的方法名 -->
                <button @click="greet">Greet</button>
                <p> {{ target }}</p>
            </div>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo191',
            data() {
                return {
                    counter: 0,
                    target: ''
                }
            },
            methods: {
                greet: function(event) {
                    // `this` 在方法里指向当前 Vue 实例
                    console.log('Hello ' + this.name + '!');
                    // `event` 是原生 DOM 事件
                    if (event) {
                        this.target
                            = "Getting from " + event.target.tagName + "'s greeting!"
                    }
                }
            }
        }
    </script>
  ```

##### 1.9.3 内联处理器中的方法
- 除了直接绑定到一个方法, 也可以在内联 JavaScript 语句中调用方法. 例如:
  ```vue
    <template>
        <div id="example-3">
            <button :click="say('hi')">Say hi</button>
            <button :click="say('what')">Say what</button>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo193',
            methods: {
                say: function(message) {
                    console.log(message)
                }
            }
        }
    </script>
  ```
  有时也需要在内联语句处理器中访问原始的 DOM 事件. 可以用特殊变量 `$event`
  把它传入方法中:
  ```vue
    <template>
        <div class="default-div">
            <h2>1.9.3: 内联处理器中的方法 + `$event`</h2>
            <p>
                <button @click="warn('Form cannot be submitted yet!', $event)">
                    Submit
                </button>
            </p>
            <p>{{ msg }}</p>
        </div>
    </template>
    <script>
        export default {
            name: 'Demo193',
            data() {
                return {
                    msg: ''
                }
            },
            methods: {
                warn: function(message, event) {
                    // - 现在我们可以访问原生事件对象
                    if (event) {
                        event.preventDefault()
                    }
                    this.msg = message + ' ' + event.target.tagName;
                }
            }
        }
    </script>
  ```

##### 1.9.4 事件修饰符
- 在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()`
  是非常常见的需求. 尽管我们可以在方法中轻松实现这点, 但更好的方式是:
  方法只有纯粹的数据逻辑, 而不是去处理 DOM 事件细节.
    + **Added:** "DOM2 级事件" 定义了两个方法,
      用于处理指定和删除事件处理程序的操作: `addEventListener()` 和
      `removeEventListener()`. 所有 DOM 节点中都包含这两个方法,
      并且它们都接受 3 个参数:
        + (1) 要处理的事件名,
        + (2) 作为事件处理程序的函数和一个布尔值.
        + (3) 最后这个布尔值参数如果是 `true`,
          表示在"捕获阶段(capture)"调用事件处理程序; 如果是 `false`,
          表示在"冒泡阶段(bubble)"调用事件处理程序. 
          要在按钮上为 click 事件添加事件处理程序, 可以使用下列代码:
          ```js
            var btn = document.getElementById("myBtn");
            btn.addEventListener("click", function(){
                console.log(this.id);
            }, false);
          ```
    + **More:** 事件的详细讲解见: 《JavaScript高级程序设计》的 第 13 章.

  为了解决这个问题. Vue.js 为 `v-on` 提供了 **事件修饰符**. 之前提过,
  修饰符是由点开头的指令后缀来表示的.
    + `.stop`: 等于 `event.stopPropagation()` 取消事件的进一步捕获或冒泡.
    + `.prevent`:  等于 `event.preventDefault()` 取消事件的默认行为.
    + `.capture`: 添加事件监听时使用事件捕获模式.
        - "DOM2及事件" 规定的事件流包括 3 个阶段: `事件捕获阶段`,
          `处于目标阶段` 和 `事件冒泡阶段`. 更多信息见 <JS高程> 13.1.3.
    + `.self`: 只当 `event.target` 是当前元素自身时才会触发处理函数.
    + `.once`: 2.1.4 新增. 表示事件只触发一次. (Note: 详细可以见仓库:
      `JS-book-learning/《JavaScript高级程序设计》/Chapter13-事件/chapter13-事件.md`)
    + `.passive`: 解释见下面
- 我们来看下大致的使用方式:
  ```html
    <!-- 阻止单击事件继续传播 -->
    <a @click.stop="doThis"></a>

    <!-- 提交事件不再重载页面 -->
    <form @submit.prevent="onSubmit"></form>

    <!-- 修饰符可以串联 -->
    <a @click.stop.prevent="doThat"></a>

    <!-- 只有修修饰符 -->
    <form @submit.prevent></form>

    <!-- 添加事件监听器时使用事件捕获模式 -->
    <!-- 即内部元素触发的事件先在此处理, 然后才交由内部元素进行处理 -->
    <div @click.captue="doThis">...</div>
    
    <!-- 只当 event.target 是当前元素自身时触发处理函数 -->
    <!-- 即事件不是从内部元素触发的 -->
    <div @click.self="doThat">...</div>
  ```

  **注意:** 使用修饰符时, 顺序很重要; 相应的代码会以同样的顺序产生. 因此,
  用 `@click.prevent.self` 会组织**所有的点击**, 而 `@click.self.prevent`
  追回阻止对元素自身的点击.

  > 2.1.4 新增
  ```html
    <!-- 点击事件只会触发一次 -->
    <a @click.once="doThis"></a>
  ```
  不像其它只能对原生的 DOM 事件起作用的修饰符, `.once`
  修饰符还能被用到`自定义组件事件`(`../02-深入了解组件/2.3-自定义事件.md`)上.
  如果你还没有阅读关于组件的文档, 现在大可不必担心.

  > 2.3.0 新增

  Vue 还对 `addEventListener` 中的 `passive`
    [选项](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)
    提供了 `.passive` 修饰符.
    - Tip: `passive`值为 `Boolean`. 设置为 `true` 时, 表示 `listener`
      永远不会调用 `preventDefault()`.
  ```html
    <!-- 滚动事件的默认行为 (即滚动行为) 将会立即出发, 而不会等待 `onScroll`
      完成. 这其中包含 `event.preventDefault()` 的情况. -->
    <div @scroll.passive="onScroll">...</div>
  ```
  这个 `.passive` 修饰符尤其能够提升移动端的性能.
  
  **注意:** 不要把 `.passive` 和 `.prevent` 一起使用, 因为 `.prevent`
  将会被忽略, 同时浏览器可能会向你展示一个警告. 请记住, `.passive`
  会告诉浏览器你不想阻止事件的默认行为.

##### 1.9.5 按键修饰符
- 在监听键盘事件时, 我们经常需要检查详细的按键. Vue 允许为 `v-on`
  在监听键盘事件时添加按键修饰符:
  ```html
    <!-- 只有 `key` 是 `Enter` 时调用 `vm.submit()` -->
    <input @keyup.enter="submit">
  ```
  你也可以直接将 `KeyboardEvent.key` 暴露的任意有效按键名转换为 kebab-case
  来作为修饰符.
  ```html
    <input @click.page-down="onPageDown">
  ```
  在上述示例中, 处理函数只会在 `$event.key` 等于 `PageDown` 时被调用.
- 19.5.1 按键码
    + **Warning:** `keyCode`的事件用法
      [已经被废弃了](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode)
      并可能不会被最新的浏览器支持.
    + 使用 `keyCode`(按键码) attribute(特性)也是允许的:
      ```html
        <input @keyup.13="submit">
      ```
      为了在必要的情况下支持旧浏览器, Vue 提供了绝大多数常用的按键码的别名:
        - (1) `.enter`
        - (2) `.tab`
        - (3) `.delete` (捕获 `删除` 和 `退格` 键)
        - (4) `.esc`
        - (5) `.space`
        - (6) `.up`
        - (7) `.down`
        - (8) `.left`
        - (9) `.right`
    + **注意:** 有一些按键(`.esc` 以及所有的方向键) 在 IE9 中有不同的 `key` 值,
      如果你想支持 IE9, 这些内置的别名应该是首选.
    + 你也可以通过全局 `config.keyCodes` 对象
      [自定义按键修饰符别名](https://cn.vuejs.org/v2/api/#keyCodes):
      ```js
        // - 可以使用 `v-on:keyup.f1`
        Vue.config.keyCodes.f1 = 112
      ```

##### 1.9.6 系统修饰键
- > 2.1.0 新增
  
  可以用如下修饰符来实现仅在按下相应按键时才出发鼠标或键盘事件的监听器.
    + (1) `.ctrl`
    + (2) `.alt`
    + (3) `.shift`
    + (4) `.meta`
- **注意:** 在 Mac 系统键盘上, meta 对应 command 键(⌘). 在 Windows
  系统键盘 meta 对应 Windows 徽标键(⊞). 在 Sun 操作系统键盘上, meta
  对应实心宝石键(◆). 在其他特定键盘上, 尤其在 MIT 和 Lisp 机器的键盘,
  以及其后继产品, 比如 Knight 键盘、space-cadet 键盘, meta 被标记为“META”.
  在 Symbolics 键盘上, meta 被标记为“META”或者“Meta”. 
- 例如:
  ```html
    <!-- Alt + C -->
    <input @keyup.alt.67="clear">

    <!-- Ctrl + Click -->
    <div @click.ctrl="doSomething">Do Something</div>
  ```
- **Warning:** 请注意修饰键与常规按键不同, 在和 `keyup` 事件一起用时,
  事件触发时修饰键必须处于按下状态. 换句话说, 只有在按住 `ctrl` 的情况下释放其它按键,
  才能触发 `keyup.ctrl`. 而单单释放 `ctrl` 也不会触发事件. 如果你想要这样的行为,
  请为 `ctrl` 换用 keyCode: `keyup.17`. 

- 1.9.6.1 `.exact`(精确的) 修饰符
    + `.exact` 修饰符允许你控制由精确的系统修饰符组合触发的事件.
      ```html
        <!-- 本例式 `@click.ctrl` 为 按下 `Ctrl + A` 键事件会被触发,
            但是即使 Alt 或 Shift 被一同按下也是可以被触发的.  -->
        <button @click.ctrl="onClick">A</button>
        
        <!-- 有且只有 Ctrl 被按下的时候才会被触发 -->
        <button @click.ctrl.exact="onCtrlClick">A</button>
        
        <!-- 没有任何系统修饰符被按下的时候才触发 -->
        <button @click.exact="onclick">A</button>
      ```
- 1.9.6.2 鼠标按钮修饰符
    + > 2.2.0 新增
      
      (1) `.left`
      (2) `.right`
      (3) `.middle`

      这些修饰符会限制处理函数仅响应特定的鼠标按钮.

##### 1.9.7 为什么在 `HTML` 中监听事件?
- 你可能注意到这种事件监听的方式违背了关注点分离(separation of concern)
  这个长期以来的优良传统. 但不必担心, 因为所有的 Vue.js
  事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上, 它不会导致任何维护上的困难.
  实际上, 使用 v-on 有几个好处:
    1. 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法.
    2. 因为你无须在 JavaScript 里手动绑定事件, 你的 ViewModel(视图模型)
       代码可以是非常纯粹的逻辑, 和 DOM 完全解耦, 更易于测试.
    3. 当一个 ViewModel 被销毁时, 所有的事件处理器都会自动被删除.
       你无须担心如何清理它们.