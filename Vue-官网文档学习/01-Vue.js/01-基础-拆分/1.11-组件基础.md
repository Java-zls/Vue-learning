# 1.11 组件基础

## 目录(Catalog)
- 1.11 组件基础
    + 1.11.1 基础示例 
    + 1.11.2 组件的复用
        - 1.11.2.1 `data` 必须是一个函数
    + 1.11.3 组件的组织
    + 1.11.4 通过 `Prop` 向子组件传递数据
    + 1.11.5 单个根元素
    + 1.11.6 监听子组件事件
        - 1.11.6.1 使用事件抛出一个值
        - 1.11.6.2 在组件上使用 `v-model`
    + 1.11.7 通过插槽分发内容 
    + 1.11.8 动态组件
    + 1.11.9 解析 `DOM` 模板时的注意事项


## 生词(New Words)
- **enlarge [ɪn'lɑrdʒ] --vt.使增大; 扩大; 放大. --vi.扩大; 放大**
    + enlarge(vt) a photograph. 放大照片.
- **dwindle ['dwɪndl] --vi.渐渐变小; 逐渐变小**
    + The population is dwindling. 人口在逐渐减少.
- **tab [tæb] --n.标签; 账单; 制表**
    + The first tab is appended at this time. 第一个标签页是在这个时候加载的.
    + Quick Tab. 快速标签.
- **post [post] --n.邮件; 职位; 柱子; 标杆. --v.邮寄; 公布; 张贴. --vi.快速行进**
    + tab posts. 标签页
    + The post(n) hasn't come yet. 邮件还没来.
    + I had a heavy post(n) yesterday. 我昨天收到很多邮件.
    + the Sunday Post(n). 星期日邮报.
    + I posted(vt) him a Christmas card. 我寄给他一张圣诞卡.
- **archive [ˈɑ:kaiv] --v.存档  --n.档案文件**
    + tab archive. 标签档案.
    + This repository has been archived by the owner. It is now read-only.
      该存储库已由所有者归档. 他现在是只读的. 



## 内容(Content)
### 1.11 组件基础
##### 1.11.1 基础示例 
- 这里有一个 Vue 组件的示例
  ```vue
    <template>
        <div id="app1111" class="default-div">
            <h2>1.11.1 组件基础-基本示例</h2>
        <button @click="count++">You clicked me {{ count }} times.</button>
        </div>
    </template>
    <script>
        export default {
            name: 'ButtonCounter',
            data() {
                return {
                    count: 0
                }
            },

        }
    </script>
  ```
  组件是可复用的 Vue 实例, 且带有一个名字: 在这个例子中我们默认的 name 为
  ButtonCounter. 我们可以在一个通过 `new Vue` 创建的 Vue 根实例中,
  把这个组件作为自定义元素来使用: 
  ```vue
    <!-- 在 App.vue 中我们导入 ButtonCounter 组件 -->
    <template>
        <div>
            <button-counter/>
        </div>
    </template>
    <script>
        import ButtonCounter from './components/1.11.1';
        export default {
            name: 'App',
            data() {
                return {
                    seen: false,
                }
            },
            components: {
                ButtonCounter
            }
        }
    </script>
  ```
  因为组件是可复用的 Vue 实例, 所以它们与 `new Vue` 接受相同的选项, 例如 `data`,
  `computed`, `watch`, `methods` 以及生命周期钩子等. 仅有的例外是像 `el`
  这样的根实例特有的选项.
- Vue 官网文档是使用的 html 页面引入 Vue 文件的形式来使用组件的,
  而上面我们的示例是使用的单文件组件(`*.vue`); 为了预防以后可能会在 html
  页面中使用 Vue 组件, 现在把官网文档的示例也添加一下:
  ```html
    <!doctype html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport"
            content="width=device-width, user-scalable=no,
                initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Document</title>
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    </head>
    <body>
        <div id="app">
            <h2>Vue.js App</h2>
            <div id="components-demo">
                <button-counter></button-counter>
            </div>
        </div>

        <script>
            // - 定义一个名为 button-counter 的新组建
            Vue.component('button-counter', {
                data: function() {
                    return {
                        count: 0
                    }
                },
                template: '<button @click="count++"> You clicked me {{ count}} times. </button>'
            });

            new Vue({
                el: '#components-demo'
            })
        </script>
    </body>
    </html>
  ```

##### 1.11.2 组件的复用
- 我们可以将组件进行任意次数的复用. 例如:
  ```vue
    <!-- App.vue 文件 -->
    <template>
        <div>
            <button-counter/>
            <button-counter/>
            <button-counter/>
        </div>
    </template>
    <script>
  ```
  注意当你点击按钮时, 每个组件都会各自独立维护它的 `count`. 因为你每用一次组件,
  就会有一个它的新实例被创建.
- 1.11.2.1 `data` 必须是一个函数
    + **一个组件的 `data` 选项必须是一个函数,**
      因此每个实例可以维护一份被返回对象的独立的拷贝.
    + 更多讲解见 `../../Vue 组件中的 data 讲解`

##### 1.11.3 组件的组织
- 通常一个应用会以一颗嵌套的组件树的形式来组织:
  
  <img src="../vue-document-images/components-tree.png"
    style="width: 90%; margin-left: 0;">

  例如, 你可能会有页头, 侧边栏, 内容区等组件, 每个组件又包含了其它的像导航链接,
  博客之类的组件.

  为了能在模板中使用, 这些组件必须先注册以便 Vue 能够识别. 这里有 2 种组件的注册类型:
  **全局注册** 和 **局部注册**. 目前为止, 我们的组件都是通过 `Vue.componnet`
  全局注册的:
  ```js
    Vue.component('my-component-name', {
        // ... options ...
    })
  ```
  全局注册的组件可以用在其被注册之后的任何(通过 `new Vue`) 新创建的 Vue 根实例中,
  也包括其组件树中的所有子组件的模板中.

  到目前为止, 关于组件注册你需要了解的就这些了, 如果你阅读完本页内容并掌握了它的内容,
  我们会推荐你再回来把 `组件注册`(`../02-深入了解组件/2.1-组件注册.md`) 读完.

##### 1.11.4 通过 `Prop` 向子组件传递数据
- 早些时候, 我们提到了创建一个博客组件的事情.
  问题是如果你不能向这个组件传递某一篇博客的标题或内容之类的我们想展示的数据的话,
  它是没有办法使用的. 这也正是 prop 的由来. 

  **Prop 是你可以在组件上注册的一些自定义特性(attribute). 当一个值传递给一个
  prop 特性的时候, 它就变成了那个组件实例的一个属性.**
  为了给博客组件传递一个标题, 我们可以用一个 `props`
  选项将其包含在该组件可接受的 prop 列表中:
  ```js
    Vue.component('blog-post', {
        props: ['title'],
        template: '<h3>{{ title }}</h3>'
    })
  ```
  一个组件默认可以拥有任意数量的 prop, 任何值都可以传递给任何 prop. 在上述模板中,
  你会发现我们能够在组件实例中访问这个值, 就像访问 data 中的值一样. 

  一个 prop 被注册之后, 你就可以像这样把数据作为一个自定义 attribute 传递进来:
  ```html
    <blog-post title="My journey with Vue"></blog-post>
    <blog-post title="Blogging with Vue"></blog-post>
    <blog-post title="Why Vue is so fun"></blog-post>
  ```
  然而在一个典型的应用中, 你可能在 `data` 里有一个博客的数组:
  ```js
    new Vue({
        el: '#blog-post-demo',
        data: {
            posts: [
            { id: 1, title: 'My journey with Vue' },
            { id: 2, title: 'Blogging with Vue' },
            { id: 3, title: 'Why Vue is so fun' }
            ]
        }
    })
  ```
  并想要为每篇博客渲染一个组件:
  ```html
    <blog-post
        v-for="post in posts"
        v-bind:key="post.id"
        v-bind:title="post.title"
    ></blog-post>
  ```
  如上所示, 你会发现我们可以使用 `v-bind` 来动态传递 prop.
  这在你一开始不清楚要渲染的具体内容, 比如从
  [从一个 API 获取博客列表](https://jsfiddle.net/chrisvfritz/sbLgr0ad)
  的时候, 是非常有用的.

  到目前为止, 关于 prop 你需要了解的大概就这些了, 如果你阅读完本页内容并掌握了它的内容, 我们会推荐你再回来把 `prop`(`../02-深入了解组件/2.2-Prop.md`) 读完. 

##### 1.11.5 单个根元素
- 当构建一个 `<blog-post>` 组件时, 你的模板最终会包含的东西远不止一个标题:
  ```html
    <h3>{{ title }}</h3>
  ```
  最最起码, 你会包含这篇博客的正文:
  ```html
    <h3>{{ title }}</h3>
    <div v-html="content"></div>
  ```
  然而如果你在模板中尝试这样写, Vue 会显示一个错误, 并解释道
  every component must have a single root element (每个组件必须只有一个根元素)
  . 你可以将模板的内容包裹在一个父元素内, 来修复这个问题, 例如:
  ```html
    <div class="blog-post">
        <h3>{{ title }}</h3>
        <div v-html="content"></div>
    </div>
  ```
  看起来当组件变得越来越复杂的时候, 我们的博客不只需要标题和内容, 还需要发布日期, 
  评论等等. 为每个相关的信息定义一个 prop 会变得很麻烦:
  ```html
    <blog-post
        v-for="post in posts"
        v-bind:key="post.id"
        v-bind:title="post.title"
        v-bind:content="post.content"
        v-bind:publishedAt="post.publishedAt"
        v-bind:comments="post.comments"
    ></blog-post>
  ```
  所以是时候重构一下这个 `<blog-post>` 组件了, 让它变成接受一个单独的 post prop:
  ```html
    <blog-post
        v-for="post in posts"
        v-bind:key="post.id"
        v-bind:post="post"
    ></blog-post>
  ```
  ```js
    Vue.component('blog-post', {
        props: ['post'],
        template: `
            <div class="blog-post">
            <h3>{{ post.title }}</h3>
            <div v-html="post.content"></div>
            </div>
        `
    })
  ```
  **Warning:** 上述的这个和一些接下来的示例使用了 JavaScript
  的模板字符串来让多行的模板更易读. 它们在 IE 下并没有被支持, 所以如果你需要在不
  (经过 Babel 或 TypeScript 之类的工具) 编译的情况下支持 IE,
  请使用折行转义字符取而代之. 

  现在, 不论何时为 post 对象添加一个新的属性, 它都会自动地在 `<blog-post>` 内可用. 

##### 1.11.6 监听子组件事件
- 在我们开发 `<blog-post>` 组件时, 它的一些功能可能要求我们和父级组件进行沟通.
  例如我们可能会引入一个辅助功能来放大博客的文字, 同时让页面的其他部分保持默认的字号.
  我们来看一下这个完整的示例.
  ```vue
    <template>
        <div id="app1116" class="default-div">
            <h2>1.11.6: 监听子组件事件</h2>
            <div :style="{fontSize: postFontSize + 'em'}">
                <!-- `:post="post"` 动态绑定一个 post 属性(注: 也可以传递静态属性)
                    给子组件 `blog-post`, 子组件在 `props` 属性内接收. -->
                <blog-post
                    v-for="post in posts"
                    :key="post.id"
                    :post="post"
                    @enlarge-text="postFontSize += 0.1"
                    @dwindle-text="postFontSize -= 0.1"
                ></blog-post>  <!-- {0-2} -->
            </div>
        </div>
    </template>
    <script>
        import BlogPost from './Prop-son-component';
        export default {
            name: 'Demo1116',
            data() {
                return {
                    posts: [
                        {
                            id: 0,
                            title: '我是博客的标题',
                            content: '我是博客内容, 主要是测试利用 Prop 从父组件传值给子组件,' +
                                '子组件接受后, 再利用 $emit() 方法并传入事件名来触发一个回传事件,' +
                                '父组件接受该事件并做出相应的操作.'
                        }
                    ], 
                    postFontSize: 1,    // {0-1}
                }
            },
            components: {
                BlogPost,
            }
        }
    </script>

    <style scoped>
        #app1116 {
            height: auto;
            min-height: 260px;
        }
    </style>
  ```
  在其父组件中, 我们可以通过添加一个 `postFontSize` 数据属性来支持这个功能(`行{0-1}`),
  它可以在模板中控制子组件, 博客文章的字号. 我们来看一下子组件代码:
  ```vue
    <template>
        <div class="blog-post default-div">
            <h3>{{ post.title }}</h3>
            <div class="button-wrapper">
                <button @click="$emit('enlarge-text')">Enlarge text</button> <!-- {1-1} -->
                <button @click="$emit('dwindle-text')">Dwindle text</button> <!-- {1-2} -->
            </div>
            <div v-html="post.content"></div>
        </div>
    </template>

    <script>
        export default {
            name: 'BlogPost',
            props: ['post'],
        }
    </script>
  ```
  我们在子组件上添加了 enlarge-text(放大字体) 和 dwindle-text(缩小字体) 2 个按钮.
  Vue 实例提供了一个自定义事件的系统来解决父子组件通信的问题, 父组件可以像处理
  native DOM 事件一样通过 `v-on` 监听子组件实例的任意事件: 见父组件的 `行{0-2}`.

  同时子组件可以通过调用内建的 `$emit`
  [方法](https://cn.vuejs.org/v2/api/#vm-emit) 并**传入事件名**来触发一个事件.
  见上面的 `行{1-1}` 和 `行{1-2}`

  有了这个 `v-on:enlarge-text="postFontSize += 0.1"` 监听器,
  父级组件就会接收该事件并更新 `postFontSize` 的值.
- 1.11.6.1 使用事件抛出一个值
    + 有的时候用一个事件来抛出一个特定的值是非常有用的, 例如我们可能想让
      `<blog-post>` 组件决定它的文本要放大多少, 这时可以使用 `$emit`
      的第二个参数来提供这个值. 还是上面的例子, 更该为:
      ```html
        <!-- 子组件 -->
        <button @click="$emit('enlarge-text', 0.1)">Enlarge text</button>
      ```
      然后挡在父级组件监听这个事件的时候, 我们通过 `$event` 访问到被抛出的这个值:
      ```html
        <blog-post
            ...
            v-on:enlarge-text="postFontSize += $event"
        ></blog-post>
      ```
      或者, 如果 `@enlarge-text` 后的事件处理函数是一个方法:
      ```html
        <blog-post
            ...
            v-on:enlarge-text="onEnlargeText"
        ></blog-post>
      ```
      那么这个值将会作为第一个参数传入这个方法:
      ```js
        methods: {
            onEnlargeText: function(enlargeAmount) {
                this.postFontSize += enlargeAmount
            }
        }
      ```
- 1.11.6.2 在组件上使用 `v-model`
    
    + 自定义事件也可以用于创建支持 `v-model` 的自定义输入组件. 记住:
      ```html
        <input v-model="searchText">
      ```
      等价于:
      ```html
        <input
            v-bind:value="searchText"
            v-on:input="searchText = $event.target.value"
        >
      ```
      当用在组件上时, `v-model` 则会这样:
      ```html
        <custom-input
            v-bind:value="searchText"
            v-on:input="searchText = $event"
        ></custom-input>
      ```
      为了让它正常工作, 这个组件内的 `<input>` 必须:
        - (1) 将其 `value` 特性绑定到一个名叫 `value` 的 prop 上.
        - (2) 在其 `input` 事件被触发时, 将新的值通过自定义的 `input` 事件抛出.
      
      写成代码是这样的:
      ```vue
        <!-- 父组件 -->
        <template>
            <div id="app11162" class="default-div">
                <h2>1.11.6.2 在组件上使用 v-model</h2>
                <custom-input v-model="searchText"></custom-input>
                <p>输入框中的值为:  {{ searchText }}</p>
            </div>
        </template>
        <script>
            import CustomInput from './component_use_v-model';
            export default {
                name: 'Demo11162',
                data() {
                    return {
                        searchText: ''
                    }
                },
                components: {
                    CustomInput,
                }
            }
        </script>
      ```
      ```vue
        <!-- 子组件 -->
        <template>
            <div id="custom-input">
                <p>当前为子组件 custom-input</p>
                <input
                    :value="value"
                    @input="$emit('input', $event.target.value)"
                >
            </div>
        </template>
        <script>
            export default {
                name: 'CustomInput',
                props: ['value'],
            }
        </script>
      ```

##### 1.11.7 通过插槽分发内容 
- 和 HTML 元素一样, 我们经常需要向一个组件传递内容, 像这样:
  ```html
    <alert-box>Something bad happened</alert-box>
  ```
  可能会渲染出这样的东西:
  <img src="../vue-document-images/error-tip.png"
    style="width: 90%; margin-left: 0;">

  幸好 Vue 自定义的 `<slot>` 元素让这变得非常简单:
  ```vue
    Vue.component('alert-box', {
        template: `
            <div class="demo-alert-box">
                <strong>Error!</strong>
                <slot></slot>
            </div>
        `
    })
  ```
  如你所见, 我们只要在需要的地方加入插槽就行了.
  
  到目前为止, 关于插槽你需要了解的大概就这么些了,
  如果你阅读完本页并掌握了这些内容, 请接着学习, 在
  `../02-深入了解组件/2.4-插槽.md` 一章会有更详细的讲解.

##### 1.11.8 动态组件
- 有的时候, 在不同组件之间进行动态切换是非常有用的, 比如在一个多标签的界面里:
  <img src="../vue-document-images/dynamic-component.png"
    style="width: 79%; margin-left: 0;">
  
  上述内容可以通过 Vue 的 `<component>` 元素加上一个特殊的 `is` 特性(attribute)
  来实现:
  ```html
    <!-- 组件会在 `currentTabComponent` 改变自动切换 -->
    <component v-bind:is="currentTabComponent"></component>
  ```
  上面的示例中, `currentTabComponent` 可以包括:
    + (1) 已注册组件的名字
    + (2) 或 一个组件的选项对象
  
  你可以在
  [这里](https://jsfiddle.net/chrisvfritz/o3nycadu/)
  查阅并体验完整的代码, 或在
  [这个版本](https://jsfiddle.net/chrisvfritz/b2qj69o1/)
  了解绑定组件选项对象, 而不是已注册组件名的示例.

  在此处给出单文件组件(`.vue`)的示例写法:
  ```vue
    <template>
        <div id="app1118" class="default-div">
            <h2>1.11.8: 动态组件</h2>
            <div class="dynamic-component">
                <button
                    v-for="tab in tabs"
                    :key="tab"
                    :class="['tab-button', {active: currentTab === tab}]"
                    @click="currentTab = tab"
                >{{ tab }}</button>
                <component
                    class="tab"
                    :is="currentTabComponent"
                ></component>
            </div>
        </div>
    </template>
    <script>
        import TabHome from './tab-home';
        import TabPosts from './tab-posts';
        import TabArchive from './tab-archive';

        export default {
            name: 'Demo1118',
            data() {
                return {
                    currentTab: '',
                    tabs: ['Home', 'Posts', 'Archive'],
                }
            },
            created() {
                this.currentTab = this.tabs[0];
            },
            computed: {
                currentTabComponent: function() {
                    return 'tab-' + this.currentTab.toLowerCase();
                }
            },
            components: {
                TabHome,
                TabPosts,
                TabArchive,
            }
        }
    </script>
    <style scoped>
        .tab-button {
            padding: 6px 10px;
            border-top-left-radius: 3px;
            border-top-right-radius: 3px;
            border: 1px solid #ccc;
            cursor: pointer;
            background-color: #f0f0f0;
            margin-bottom: -1px;
            margin-right: -1px;
        }
        .tab-button:hover {
            background: #e0e0e0;
        }
        .tab-button.active {
            background: #e0e0e0;
        }
        .tab {
            border: 1px solid #ccc;
            padding: 10px;
        }
    </style>
  ```

  请留意, 这个 特性(attribute) 可以用于常规 HTML 元素, 但这些元素将被视为组件,
  这意味着所有的 attribute 都会作为 DOM attribute 被绑定. 对于像 value
  这样的 property, 若想让其如预期般工作, 你需要使用   
  [`.prop` 修饰符](https://cn.vuejs.org/v2/api/#v-bind).

  到目前为止, 关于动态组件你需要了解的大概就这些了, 如果你阅读完本页内容并掌握了它的内容,
  我们会推荐你再回来把
  `动态和异步组件`(`../02-深入了解组件/2.5-动态组件和异步组件.md`) 读完.

##### 1.11.9 解析 `DOM` 模板时的注意事项
- 有些 HTML 元素, 诸如 `<ul>`, `<ol>`, `<table>` 和 `<select>`,
  对于哪些元素可以出现在其内部是有严格限制的. 而有些元素, 诸如 `<li>`, `<tr>` 和
  `<option>`, 只能出现在其它某些特定的元素内部. 

  这会导致我们使用这些有约束条件的元素时遇到一些问题. 例如：
  ```html
    <table>
        <blog-post-row></blog-post-row>
    </table>
  ```
  这个自定义组件 `<blog-post-row>` 会被作为无效的内容提升到外部,
  并导致最终渲染结果出错. 幸好这个特殊的 `is` 特性(attribute) 给了我们一个变通的办法:
  ```html
    <table>
        <tr is="blog-post-row"></tr>
    </table>
  ```
  需要注意的是如果我们从以下来源使用模板的话, 这条限制是不存在的：
    + 字符串 (例如：`template: '...'`)
    + [单文件组件](https://cn.vuejs.org/v2/guide/single-file-components.html)
      (`.vue`)
    + `<script type="text/x-template">`
  
  到这里, 你需要了解的解析 DOM 模板时的注意事项——实际上也是 Vue 的全部必要内容,
  大概就是这些了. 恭喜你！接下来还有很多东西要去学习, 不过首先, 我们推荐你先休息一下,
  试用一下 Vue, 自己随意做些好玩的东西. 

  如果你感觉已经掌握了这些知识, 我们推荐你再回来把完整的组件指南,
  包括侧边栏中组件深入章节的所有页面读完. 