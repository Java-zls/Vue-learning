# 2.6 处理边界情况


## 目录(Catalog)
- 2.6 处理边界情况
    + 2.6.1 访问元素 & 组件
        - 2.6.1.1 访问根实例 
        - 2.6.1.2 访问父组件实例
        - 2.6.1.3 访问子组件实例或子元素
        - 2.6.1.4 依赖注入
    + 2.6.2 程序化的事件侦听器
    + 2.6.3 循环引用
        - 2.6.3.1 循环组件
        - 2.6.3.2 组件之间的循环引用
    + 2.6.4 模板定义的替代品
        - 2.6.4.1 内联模板
        - 2.6.4.2 `X-Template`
    + 2.6.5 控制更新
        - 2.6.5.1 强制更新
        - 2.6.5.2 通过 `v-once` 创建低开销的静态组件



## 生词(New Words)
- **store [stɔr] --n.商店; 存储; 储藏. --vt.存储,储备; 供给. --vi.可存储**
    + a candy store. 糖果店
    + buy things at a store. 在商店购物
    + The department store(n) was thronged[θrɔŋ] with people.
      百货商店挤满了人.
    + a great store(n) of wine[waɪn]. 储存大量葡萄酒.
    + store(vt) the mind with knowledge. 以知识充实自己.
    + This food stores(vi) well. 这种食品可存储.



## 内容(Content)
> 该页面假设你已经阅读过了 `组件基础`(`../01-基础/1.11-组件基础.md`).
  如果你还对组件不太了解, 推荐你先阅读它. 
### 2.6 处理边界情况
- **Warning:** 这里记录的都是和处理边界情况有关的功能, 即一些需要对 Vue
  的规则做一些小调整的特殊情况. 不过注意这些功能都是有劣势或危险的场景的.
  我们会在每个案例中注明, 所以当你使用每个功能的时候请稍加留意. 
##### 2.6.1 访问元素 & 组件
- 在绝大多数情况下, 我们最好不要触达另一个组件实例内部或手动操作 DOM 元素.
  不过也确实在一些情况下做这些事情是合适的. 
- **2.6.1.1 访问根实例**
    + 在每个 `new Vue` 实例的子组件中, 其根实例可以通过 `$root` 属性进行访问.
      例如, 在这个根实例中:
      ```js
        // - Vue 根实例
        new Vue({
            data: {
                foo: 1
            },
            computed: {
                bar: function () { /* ... */ }
            },
            methods: {
                baz: function () { /* ... */ }
            }
        })
      ```
      所有的子组件都可以将这个实例作为一个全局 store 来访问或使用. 例如:
      ```js
        // - 获取根组件的数据
        this.$root.foo;
        
        // - 写入根组件的数据
        this.$root.foo = 2;

        // - 访问根组件的计算属性
        this.$root.bar

        // - 调用根组件的方法
        this.$root.baz()
      ```
      **Warning:** 对于 demo 或非常小型的有少量组件的应用来说这是很方便的.
      不过这个模式扩展到中大型应用来说就不然了.因此在绝大多数情况下,
      我们强烈推荐使用 [Vuex](https://github.com/vuejs/vuex) 来管理应用的状态.

- **2.6.1.2 访问父组件实例**
    + 和 `$root` 类似, `$parent` 属性可以用来从一个子组件访问父组件的实例.
      它提供了一种机会, 可以在后期随时触达父级组件, 以替代将数据以 prop
      的方式传入子组件.
    + **Warning:** 在绝大多数情况下, 触达父级组件会使得你的应用更难调试和理解,
      尤其是当你变更了父级组件的数据的时候. 当我们稍后回看那个组件的时候,
      很难找出那个变更是从哪里发起的.
    + 然而在有些情况下, 特别是共享组件库,这可能是合适的. 举个例子, 在和
      JavaScript API 进行交互而不渲染 HTML 的抽象组件内, 例如这里假设性的
      Google 地图组件: 
      ```html
        <google-map>
            <google-map-markers :places="iceCreamShops"></google-map-markers>
        </google-map>
      ```
      这个 `<google-map>` 组件可以定义一个 `map` 属性, 所有的子组件都需要访问它.
      在这种情况下 `<google-map-markers>` 可能想要通过类似 `this.$parent.getMap`
      的方式访问那个地图, 以便为其添加一组标记. 你可以在
      [这里](https://jsfiddle.net/chrisvfritz/ttzutdxh/) 看到实现代码.
      (tip: 此示例会调用 google map 接口, 暂略.)

      请留意, 尽管如此, 通过这种模式构建出来的那个组件的内部仍然是容易出问题的. 比如,
      设想一下我们添加一个新的 `<google-map-region>` 组件, 当 `<google-map-markers>`
      在其内部出现的时候, 只会渲染那个区域内的标记:
      ```html
        <google-map>
            <google-map-region :shape="cityBoundaries">
                <google-map-markes :places="iceCreamShops"></google-map-markes>
            </google-map-region>
        </google-map>
      ```
      那么在 `<google-map-markes>` 内部你可能发现自己需要一些类似这样的 hack:
      ```js
        var map = this.$parent.map || this.$parent.$parent.map
      ```
      很快它就会失控. 这也是我们针对需要向任意更深层级的组件提供上下文信息时推荐
      `依赖注入`(下面 2.6.1.4) 的原因. 
- **2.6.1.3 访问子组件实例或子元素**
    + 尽管存在 prop 和事件, 有的时候你仍可能需要在 JavaScript
      里直接访问一个子组件. 为了达到这个目的, 你可以通过 `ref`
      这个特性为子组件赋予一个 ID 引用. 例如:
      ```html
        <base-input ref="usernameInput"></base-input>
      ```
      现在在你已经定义了这个 `ref` 的组件里, 你可以这样使用:
      ```js
        this.$refs.usernameInput
      ```
      来访问这个 `<base-input>` 实例, 以便不时之需.
      比如程序化地从一个父组件聚焦这个输入框. 在刚才那个例子中, 该 `<base-input>`
      组件也可以使用一个类似的 `ref` 提供对内部这个指定元素的访问, 例如:
      ```html
        <input ref="input">
      ```
      甚至可以通过其父级组件定义方法:
      ```js
        methods: {
            // - 用来从父组件聚焦输入框
            focus: fucntion() {
                this.$refs.input.focus()
            }
        }
      ```
      这样就允许父级组件通过下面的代码聚焦 `<base-input>` 里的输入框:
      ```js
        this.$refs.usernameInput.focus()
      ```
      当 `ref` 和 `v-for` 一起使用时,
      你得到的引用将会是一个包含了对应数据源的这些子组件的数据.

      **Warning:** `$refs` 只会在组件渲染完成之后生效, 并且他们不是响应式的.
      这仅作为一个用于直接操作子组件的 "逃生舱" --
      你应该避免在模板或计算属性中访问 `$refs`.

      这里使用单文件组件的方式给出此小节的示例:

- **2.6.1.4 依赖注入**


##### 2.6.2 程序化的事件侦听器


##### 2.6.3 循环引用
- **2.6.3.1 循环组件**
- **2.6.3.2 组件之间的循环引用**


##### 2.6.4 模板定义的替代品
- **2.6.4.1 内联模板**
- **2.6.4.2 `X-Template`**


##### 2.6.5 控制更新
- **2.6.5.1 强制更新**
- **2.6.5.2 通过 `v-once` 创建低开销的静态组件**