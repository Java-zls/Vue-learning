# 2.3 自定义事件


## 目录(Catalog)
- 2.3 自定义事件
    + 2.3.1 事件名
    + 2.3.2 自定义组件的 `v-model` 
    + 2.3.3 将原生事件绑定到组件
    + 2.3.4 `.sync` 修饰符



## 生词(New Words)




## 内容(Content)
> 该页面假设你已经阅读过了 `组件基础`(`../01-基础/1.11-组件基础.md`).
  如果你还对组件不太了解, 推荐你先阅读它. 
### 2.3 自定义事件
##### 2.3.1 事件名
- 不同于组件和 prop, 事件名不存在任何自动化的大小写转换.
  而是触发的事件名需要完全匹配监听这个事件所用的名称. 举个例子,
  如果触发一个 camelCase 名字的事件:
  ```js
    this.$emit('myEvent')
  ```
  则监听这个名字的 kebab-case 版本是不会有任何效果的:
  ```html
    <!-- 没有效果 -->
    <my-component @my-event="doSomething"></my-component>
  ```
  不同于组件和 prop, 事件名不会被用作一个 JavaScript 变量名或属性名,
  所以就没有理由使用 camelCase 或 PascalCase 了. 并且 `v-on` 事件监听器在
  DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的), 所以
  `v-on:myEvent` 将会变成 `v-on:myevent` —— 导致 `myEvent` 不可能被监听到.

  因此, 我们推荐你**始终使用 kebab-case 的事件名**.

##### 2.3.2 自定义组件的 `v-model` 
- 一个组件上的 `v-model` 默认会利用名为 `value` 的 prop 和名为 `input` 的事件,
  但是像单选框, 复选框类型的输入控件可能会将 `value` 特性用于
  [不同的目的](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value).
  `model` 选项可以用来避免这样的冲突. 我们来看下面这个示例:
  ```vue
    <!-- 2.3.2.vue -->
    <template>
        <div id="Demo232" class="default-div">
            <h2>2.3.2 自定义组件的 `v-model`</h2>
            <base-checkbox
                v-model="lovingVue"
            ></base-checkbox>
        </div>
    </template>
    <script>
        import BaseCheckbox from '../base-components/base-checkbox';
        export default {
            name: 'Demo232',
            data() {
                return {
                    lovingVue: false
                }
            },
            components: {
                BaseCheckbox,
            },
            watch: {
                lovingVue: function(newValue) {
                    console.log('checkbox newValue:', newValue);
                }
            }
        }
    </script>
  ```
  ```vue
    <!-- base-checkbox.vue -->
    <template>
        <div class="base-checkbox">
            <h2>base-checkbox</h2>
            <input
                id="baseCheckbox"
                type="checkbox"
                :checked="checked"
                @change="$emit('change', $event.target.checked)"
            >
            <label for="baseCheckbox">基础复选框组件</label>
        </div>
    </template>
    <script>
        export default {
            name: 'BaseCheckbox',
            model: {
                // - 父作用域 lovingVue 的值会传给 checked 
                prop: 'checked',
                event: 'change'
            },
            props: {
                checked: Boolean
            },
        }
    </script>
    <style lang="stylus" scoped>
        @import './base-components-style.styl';
    </style>
  ```
  这里的 `lovingVue` 的值将会传入名为 `checked` 的 prop. 同时当基础组件
  `<base-checkbox>` 触发一个 `change` 事件并附带一个新的值的时候, 这个
  `lovingVue` 的属性将会被更新(即上面的代码
  `@change="$emit('change', $event.target.checked)"`).

##### 2.3.3 将原生事件绑定到组件
- 你可能有很多次想要在一个组件的根元素上直接监听一个原生事件. 这是, 你可以使用 `v-on`
  的 `.native` 修饰符:
  ```html
    <base-input v-on:focus.native="onFocus"></base-input>
  ````
  在有的时候这是很有用的, 不过在你尝试监听一个类似 `<input>` 的非常特定的元素时,
  这并不是一个好主意. 比如上述 `<base-input>` 组件可能做了如下重构,
  所以根元素实际上是一个 `<label>` 元素; 例如:
  ```vue
    <template>
        <label>
            <span> {{ label }}: </span>
            <input
                v-bind="$attrs"
                :value="value"
                @input="$emit('input', $event.target.value)"
            >
        </label>
    </template>
    <script>
        export default {
            name: 'BaseInput',
            inheritAttrs: false,
            props: ['label', 'value'],
        }
    </script>
    <style lang="stylus" scoped>
        @import "./base-components-style.styl"
    </style>
  ```
  这时, 父级的 `.native` 监听器将静默失败. 他不会产生任何报错, 但是 `onFocus`
  处理函数不会如你预期地被调用.

  为了解决这个问题, Vue 提供了一个 `$listeners` 属性, 它是一个对象,
  里面包含了作用在这个组件上的所有监听器. 例如:
  ```js
    {
        focus: function(event) { // ... },
        input: function(event) { // ... },
    }
  ```
  有了这个 `$listeners` 属性, 你就可以配合 `v-on="$listener"`
  将所有的事件监听器指向这个组件的某个特定的子元素. 对于类似 `<input>`
  的你希望它们也可以配合 `v-model` 工作的组件来说, 为这些监听器创建一个类似下述
  `inputListeners` 的计算属性通常是非常有用的. 例如:
  ```vue
    <!-- 2.3.3.vue -->
    <template>
        <div id="Demo233" class="default-div">
            <h2>2.3.3 将原生事件绑定到组件</h2>
            <base-input
                label="姓名"
                v-model="inputValue"
                v-on="$listeners"
                placeholder="Enter your name"
            ></base-input>
            <span>您的姓名为:  {{ inputValue }}</span>
        </div>
    </template>

    <script>
        import BaseInput from '../base-components/base-input';
        export default {
            name: 'Demo233',
            data() {
                return {
                    inputValue: ''
                }
            },
            components: {
                BaseInput
            }
        }
    </script>
  ```
  ```vue
    <!-- base-input.vue -->
    <template>
        <div>
            <p>基础组件 base-input</p>
            <label>
                <span> {{ label }}: </span>
                <input
                    type="text"
                    v-bind="$attrs"
                    :value="value"
                    v-on="inputListeners"
                >
            </label>
        </div>
    </template>
    <script>
        export default {
            name: 'BaseInput',
            // - 此处设置禁用继承特性
            inheritAttrs: false,
            props: ['label', 'value'],
            mounted: function() {
                // console.log(this.$attrs)
            },
            computed: {
                inputListeners: function() {
                    let vm = this;
                    // - Object.assign 将所有的对象合并为一个新对象
                    return Object.assign({},
                        // - 我们从父级添加所有的监听器
                        this.$listeners,
                        // - 然后我们添加自定义监听器, 或覆写一些监听器的行为
                        {
                            // - 这里确保组件配合 `v-model` 来工作
                            input: function(event) {
                                vm.$emit('input', event.target.value)
                            }
                        }
                    )
                }
            }
        }
    </script>
    <style lang="stylus" scoped>
        @import "./base-components-style.styl"
    </style>
  ```
  现在 `<base-iput>` 组件是一个**完全透明的包裹器了**,
  也就是说它可以完全像一个普通的 `<input>` 元素一样使用了:
  所以跟它相同的特性和监听器都可以工作.

##### 2.3.4 `.sync` 修饰符
- > 2.3.0+ 新增
- 在有些情况下, 我们可能需要对一个 prop 进行 "双向绑定". 不幸的是,
  真正的双向绑定会带来维护上的问题, 因为子组件可以修改父组件,
  且在父组件和子组件都没有明显的改动来源.
  
  这也是为什么我们推荐以 `update:myPropName` 的模式触发事件. 举个例子,
  在一个包含 `title` prop 的假设的组件中, 我们可以用以下方法表达对其赋新值的意图,
  即下面示例中的 `this.$emit('update:title', this.newTitle)`:
  ```vue
    <template>
        <div class="text-document">
            <h3>{{ title }}</h3>
            <p>{{ content }}</p>
            <button @click="updateTitle">更新文章标题</button>
        </div>
    </template>
    <script>
        export default {
            name: 'TextDocument',
            data() {
                return {
                    newTitle: '佛说五王经: 人生八苦'
                }
            },
            props: {
                title: String,
                content: String,
            },
            methods: {
                updateTitle: function(event) {
                    this.$emit('update:title', this.newTitle)
                }
            }
        }
    </script>
  ```
  然后父组件可以监听那个事件并根据需要更新一个本地的数据属性(tip: 本示例中即更新
  `article`对象属性的 `title` 的值). 例如:
  ```vue
    <template>
        <div id="Demo234" class="default-div">
            <h2>2.3.4 `.sync` 修饰符</h2>
            <text-document
                :title="article.title"
                :content="article.content"
                @update:title = "article.title = $event"
            ></text-document>
            <!-- :title.sync = "article.title" -->
        </div>
    </template>
    <script>
        import TextDocument from './text-document';
        export default {
            name: 'Demo234',
            data() {
                return {
                    article: {
                        title: "人生八苦",
                        content: "人生八苦是指: 生, 老, 病, 死, 求不得," +
                            " 怨憎会, 爱别离, 五阴盛.",
                    }
                }
            },
            components: {
                TextDocument,
            }
        }
    </script>
  ```
  此示例中的 `@update:title = "article.title = $event"` (tip: `$event`
  即子组件的 `$emit` 方法的第二个参数.)

  为了方便起见, Vue 为这种模式提供了一个缩写, 即 `.sync` 修饰符. 把上面的
  `<base-input>` 组件中的代码更改为:
  
  ```html
    <text-document
        :title="article.title"
        :content="article.content"
        :title.sync = "article.title"
    ></text-document>
    <!-- @update:title = "article.title = $event" -->
  ```
  Tip: 请注意, `v-bind:title.sync="article.title"` 使用的 `v-bind` 指令,
  它是响应式的更新 html 特性; 而 `v-on:update:title="article.title = $event"`
  是使用的 `v-on` 指令, 它用于监听 DOM 事件.

  **Warning:** 注意带有 `.sync` 修饰符的 `v-bind` 不能和表达式一起使用(例如:
  `v-bind:title.sync="doc.title + '!'"` 是无效的.) 取而代之的是,
  你只能提供你想要绑定的属性名, 类似 `v-model`.

  当我们用一个对象同时设置多个 prop 的时候, 也可以将这个 `.sync` 修饰符和 `v-bind`
  配合使用:
  ```html
    <text-document v-bind:sync="doc"></text-document>
  ```
  这样会把 `doc` 对象中的每一个属性(如: `title`) 都作为一个独立的 prop 穿进去,
  然后各自添加用于更新的 `v-on` 监听器.

  **Warning:** 将 `v-bind:sync` 用在一个字面量的对象上, 例如
  `v-bind.sync="{title: doc.title}"` 是无法正常工作的,
  因为在解析一个像这样的复杂表达式的时候, 有很多边缘情况需要考虑.