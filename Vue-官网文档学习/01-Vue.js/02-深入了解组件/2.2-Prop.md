# 2.2 `Prop`


## 目录(Catalog)
- 2.2 `Prop`
    + 2.2.1 `Prop` 的大小写
    + 2.2.2 `Prop` 类型
    + 2.2.3 传递静态或动态 `Prop`
        - 2.2.3.1 传入一个数字
        - 2.2.3.2 传入一个布尔值
        - 2.2.3.3 传入一个数组
        - 2.2.3.4 传入一个对象
        - 2.2.3.5 传入一个对象的所有属性
    + 2.2.4 单向数据流
    + 2.2.5 `Prop` 验证
        - 2.2.5.1 类型检查
    + 2.2.6 非 `Prop` 的 Attribute(特性)
        - 2.2.6.1 替换/合并 已有的 Attribute
        - 2.2.6.2 禁用 Attribute 继承



## 生词(New Words)




## 内容(Content)
### 2.2 `Prop`
> 该页面假设你已经阅读过了 `组件基础`(`../01-基础/1.11-组件基础.md`).
  如果你还对组件不太了解, 推荐你先阅读它. 

##### 2.2.1 `Prop` 的大小写(camelCase vs kebab-case)
- HTML 中的 特性(attribute) 名是大小写不敏感的,
  所以浏览器会把所有大写字符解释为小写字符. 这意味着当你使用 DOM 中的模板时,
  camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名)
  命名:
  ```js
    Vue.component('blog-post', {
        // 在 JavaScript 中是 camelCase 的
        props: ['postTitle'],
        template: '<h3>{{ postTitle }}</h3>'
    })
  ```
  ```html
    <!-- 在 HTML 中是 kebab-case 的 -->
    <blog-post post-title="hello!"></blog-post>
  ```
  重申一次, 如果你使用字符串模板, 那么这个限制就不存在了. 

##### 2.2.2 `Prop` 类型
- 到这里, 我们只看到了以字符串数组形式列出的 prop:
  ```js
    props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
  ```
  但是, 通常你希望每个 prop 都有指定的值类型. 这时, 你可以以对象形式列出 prop,
  这些属性的名称和值分别是 prop 各自的名称和类型:
  ```js
    props:{
        title: String,
        likes: Number,
        isPublished: Boolean,
        commentIds: Array,
        author: Object,
        callback: Function,
        contactsPromise: Promise,   // - or any other constructor
    }
  ```
  这不仅为你的组件提供了文档, 还会在它们遇到错误类型时从浏览器的 JavaScript
  控制台提示用户.

##### 2.2.3 传递静态或动态 `Prop`
- 可以像这样给 prop 传入一个静态的值:
  ```html
    <blog-post title="My journey with Vue"></blog-post>
  ```
  也可以通过 `v-bind` 给 prop 动态赋值. 例如:
  ```html
    <!-- 动态赋予一个变量的值 -->
    <blog-post :title="post.title"></blog-post>
    <!-- 动态赋予一个复杂表达式的值 -->
    <blog-post :title="post.title + ' by ' + post.author.name"></blog-post>
  ```
  在上述 2 个示例中, 我们传入的值都是字符串类型的, 但实际上 *任何类型*
  的值都可以传给一个 prop.
- **2.2.3.1 传入一个数字**
    + ```html
        <!-- 即便 `42` 是静态的, 我们仍然需要 `v-bind` 来告诉 Vue
             这是一个 JavaScript 表达式而不是一个字符串 -->
        <blog-post v-bind:likes="42"></blog-post>

        <!-- 用一个变量进行动态赋值 -->
        <blog-post v-bind:likes="post.likes"></blog-post>
      ```
- **2.2.3.2 传入一个布尔值**
    + ```html
        <!-- 包含该 prop 没有值的情况在内, 都意味着 `true` -->
        <blog-post is-published></blog-post>
        <!-- 即便 `false` 是静态的, 我们仍然需要 `v-bind` 来告诉 Vue
             这是一个 JavaScript 表达式而不是一个字符串 -->
        <blog-post v-bind:is-published="false"></blog-post>

        <!-- 用一个变量进行动态赋值 -->
        <blog-post v-bind:is-published="post.isPublished"></blog-post>
      ```
- **2.2.3.3 传入一个数组**
    + ```html
        <!-- 即便数组是静态的, 我们仍然需要 `v-bind` 来告诉 Vue
             这是一个 JavaScript 表达式而不是一个字符串 -->
        <blog-post v-bind:comment-ids="[234, 266, 273]"></blog-post>
        <!-- 用一个变量进行动态赋值 -->
        <blog-post v-bind:comment-ids="post.commentIds"></blog-post>
      ```
- **2.2.3.4 传入一个对象**
    + ```html
        <!-- 即便对象是静态的, 我们仍然需要 `v-bind` 来告诉 Vue
             这是一个 JavaScript 表达式而不是一个字符串 -->
        <blog-post
            :author="{
                name: 'Veronica',
                company: `Veridian Dynamics`
            }"
        ></blog-post>
        <!-- 用一个变量进行动态赋值 -->
        <blog-post v-bind:comment-ids="post.author"></blog-post>
      ```
- **2.2.3.5 传入一个对象的所有属性**
    + 如果你想将一个对象的所有属性都作为 prop 传入, 你可以使用不带参数的 `v-bind`
      (取代 `v-bind:prop-name`). 例如, 对于一个给定的对象 `post`:
      ```js
        post: {
            id: 1,
            title: `My Journey with Vue'
        }
      ```
      下面的模板:
      ```html
        <blog-post v-bind="post"></blog-post>
      ```
      等价于:
      ```html
        <blog-post
            :id="post.id"
            :title="post.title"
        ></blog-post>
      ```

##### 2.2.4 单向数据流
- 所有的 prop 都使得父子组件之间形成了一个**单向下行绑定:** 父级 prop
  的更新会向下流动到子组件中, 但是反过来则不行.
  这样可以防止子组件意外改变父组件的状态, 从而导致应用的数据流向难以理解.

  额外的, 每次父组件发生更新时, 子组件中所有的 prop 都将会刷新为最新的值.
  这意味着你不应该在一个子组件内部改变 prop. 如果你这样做了, Vue 会在浏览器中发出警告.

  这里有 2 种常见的试图改变一个 prop 的情形:

  (1) **这个 prop 用来传递一个初始值; 这个子组件接下来希望将其作为一个本地的
  prop 数据来使用**. 在这种情况下, 最好定义一个本地的 `data` 属性并将这个 prop
  用作其初始值.
  ```js
    // - .vue 组件中
    props: ['initialCounter'],
    data: function() {
        return {
            counter: this.initialCounter
        }
    }
  ```
  (2) **这个 prop 以一种原始的值传入且需要进行转换.** 在这种情况下, 最好使用这个 prop
  的值来定义一个计算属性:
  ```html
    props: ['size'],
    computed: {
        normalizedSize: function() {
            return this.size.trim().toLowerCase()
        }
    }
  ```
  **Warning**: 注意在 JavaScript 中对象和数组是通过引用传入的,
  所以对于一个数组或对象类型的 prop 来说,
  在子组件中改变这个对象或数组本身将会影响到父组件的状态.

##### 2.2.5 `Prop` 验证
- 我们可以为组件的 prop 指定验证要求, 例如你知道的这些类型. 如果有一个需求没有被满足,
  则 Vue 会在浏览器控制台中警告你. 这在开发一个会被别人用到的组件时尤其有帮助. 

  为了定制 prop 的验证方式, 你可以在组件中为 `props`
  对象属性中的值提供一个带有验证需求的对象, 而不是一个字符串数组. 例如:
  ```js
    Vue.component('my-component', {
        props: {
            // - 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
            propA: Number,
            // - 多个可能的类型
            propB: [String, Number],
            // - 必填的字符串
            propC: {
                type: String,
                required: true
            },
            // - 带有默认值的数字
            propD: {
                type: Number,
                required: 100
            },
            // - 带有默认值的对象
            propE: {
                type: Object,
                // - 对象或数组默认值必须从一个工厂函数获取
                default: function() {
                    return { message: 'hello' }
                }
            },
            // - 自定义验证函数
            propF: {
                validator: function(value) {
                    // - 这个值必须匹配下列字符串中的一个
                    return ['success', 'warning', 'danger'].indexOf(value) !== -1
                }
            }
        }
    })
  ```
  当 prop 验证失败的时候, (开发环境构建版本的) Vue 将会产生一个控制台的警告.

  **Warning:** 注意哪些 prop 会在一个组件实例创建**之前**进行验证, 所以实例的属性
  (如 `data`, `computed` 等) 在上面示例中的 `default` 或 `validator`
  函数中是不可用的.
- **2.2.5.1 类型检查**
    + `type` 可以是下列原生构造函数中的一个:
        - (1) `String` 
        - (2) `Number`  
        - (3) `Boolean`  
        - (4) `Array`  
        - (5) `Object`  
        - (6) `Date`  
        - (7) `Function`  
        - (8) `Symbol`  
        
        
      
      额外的, `type` 还可以是一个自定义的构造函数, 并且通过 `instanceof`
      来进行检查确认. 例如, 给定下列现成的构造函数:
      ```js
        function Person(firstName, lastName) {
            this.firstName = firstName;
            this.lastName = lastName
        }
      ```
      你可以使用:
      ```js
        Vue.component('blog-post', {
            props: {
                author: Person
            }
        })
      ```
      来验证 `author` prop 的值是否是通过 `new Person` 创建的.
##### 2.2.6 非 `Prop` 的 Attruibute(特性)
- 一个非 prop 的 特性(attribute) 是指传向一个组件, 但是该组件并没有相对应 prop
  定义的 特性(attribute).

  因为显式定义的 prop 适用于向一个子组件传入信息,
  然而组件库的作者并不总能预见组件会被用于怎样的场景. 这也是为什么组件可以接受任意的
  特性(attribute), 而这些 特性(attribute) 会被添加到这个组件的根元素上.

  例如, 想象一下你通过一个 Bootstrap 插件使用了一个第三方的
  `<bootstrap-date-input>` 组件, 这个组件需要在其 `<input>` 上用到一个
  `data-date-picker` 特性. 我们可以将这个特性添加到你的组件实例上:
  ```html
    <bootstrap-date-input data-date-picker="activated"></bootstrap-date-input>
  ```
  然后这个 `data-date-picker="activated"` 特性就会自动添加到
  `<bootstrap-date-input>` 的根元素上.

- **2.2.6.1 替换/合并 已有的 特性(Attribute)**
    + 想象一下 `<bootstrap-date-input>` 的模板是这样的:
      ```html
        <input type="date" class="form-control">
      ```
      为了给我们的日期选择器插件制定一个主题, 我们可能需要像这样添加一个特别的类名:
      ```html
        <bootstrap-date-input
            data-date-picker="activated"
            class="date-picker-theme-dark"
        ></bootstrap-date-input>
      ```
      在这种情况下, 我们定义了 2 个不同的 `class` 的值:
        - (1) `form-control` 这是在组件的模板内设置好的.
        - (2) `date-picker-theme-dark` 这是从组件的父级传入的
      
      对于绝大多数的特性来说, 从外部提供给组件的值会替换掉组件内部设置好的值.
      所以如果传入 `type="text"`, 就会替换掉 `type="date"` 并把它破坏!
      庆幸的是, `class` 和 `style` 特性会稍微智能一些, 即两边的值会被合并起来,
      从而得到最终的值: `form-control date-picker-theme-dark`.

- **2.2.6.2 禁用 特性(Attribute) 继承**
    + 如果你不希望组件的根元素继承特性, 你可以在组件的选项中设置
      `inheritAttrs: false`. 例如:
      ```js
        Vue.component('my-component', {
            inheritAttrs: false,
            // ...
        })
      ```
      这尤其适合配合实例的 `$attrs` 属性使用, 该属性包含了传递给一个组件的
      特性名 和 特性值, 例如:
      ```js
        {
            required: true,
            placeholder: 'Enter your username'
        }
      ```
      有了 `inheritAttrs: false` 和 `$attrs`,
      你就可以手动决定这些特性会被赋予那个元素. 在撰写基础组件的时候是常会用到的:
      ```js
        Vue.component('base-input', {
            inheritAttrs: false,
            props: ['label', 'value'],
            template: `
                <label>
                    {{ label }}
                    <input
                        v-bind="$attrs"
                        :value="value"
                        :input="$emit('input', $event.target.value)"
                    >
                </label>
        })
      ```
      **Warning:** 注意 `inheritAttrs: false` 选项不会影响 `style` 和 `class`
      的绑定.

      这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素,
      而不会担心哪个元素是真正的根元素:
      ```html
        <base-input
            v-model="username"
            required
            placeholder="Enter your username"
        ></base-input>
      ```
    + **I added:** 此处给出上面示例的单文件组件(`.vue`) 的写法:
      ```vue
        <!-- 2.2.6.2.vue -->
        <template>
            <div id="Demo2262" class="default-div">
                <h2>2.2.6.2: 禁用特性(attribute)继承</h2>
                <base-input
                    label="姓名"
                    class="username-input"
                    v-model="username"
                    placeholder="Enter your username"
                    data-date-picker="activated"
                ></base-input>
                <p>你在 input 中输入的值为: {{ username }}</p>
            </div>
        </template>
        <script>
            import BaseInput from './base-input';
            export default {
                name: 'Demo2262',
                data() {
                    return {
                        username: '',
                    }
                },
                components: {
                    BaseInput,
                }
            }
        </script>
        <style scoped>
            .username-input {
                background: #9cd5f1;
            }
        </style>
      ```
      ```vue
        <!-- base-input.vue -->
        <template>
            <div>
                <p>我是 2.2.6.2 的子组件 base-input</p>
                <label>
                    <span> {{ label }}: </span>
                    <input
                        v-bind="$attrs"
                        :value="value"
                        @input="$emit('input', $event.target.value)"
                    >
                </label>
            </div>
        </template>
        <script>
            export default {
                name: 'BaseInput',
                // - 此处设置禁用继承特性
                inheritAttrs: false,
                props: ['label', 'value'],
                mounted: function() {
                    console.log(this.$attrs)
                }
            }
        </script>
        <style scoped>
            input {
                min-width: 160px;
                min-height: 30px;
            }
        </style>
      ```
      我们使用上面的文档来解说一下这两个单文件组件; 如果不在 `base-input.vue`
      子组件中使用 `inheritAttrs: false`, 那么在控制台中渲染后的 DOM
      就如下所示: 
      ```html
        <div placeholder="Enter your username"
            data-date-picker="activated" class="username-input">
            <p>我是 2.2.6.2 的子组件 base-input</p>
            <label>
                <span> 姓名: </span>
                <input placeholder="Enter your username"
                    data-date-picker="activated">
            </label>
        </div>
      ```
      可以看到 `base-input.vue` 组件的根元素(`div`)
      继承了调用时传入的 `placeholder` 和 `data-date-picker`,
      但我们本来的意图是只需在 `input` 上继承这两个特性(attribute),
      所以 Vue 给出的解决方法是在子组件内添加 `inheritAttrs` 属性来解决.
      但是 Vue 此处也是做了处理的, 根元素可以正常接收 `class` 和 `style`
      特性, 它们不会受到影响.

      可能你也会对子组件上使用的 `v-bind="$attrs"` 不太了解, 不要着急,
      我们先来看一样官网的
      [vm.$attrs](https://cn.vuejs.org/v2/api/#vm-attrs) 解释:
      
      **`vm.$attrs`**:
        - 类型: `{[key: string]: string}`: 接受参数为一个对象, 对象的键
          `key` 为字符串, 值也为字符串.
        - 只读
        - 详细:
            + 包含了父作用域中不作为 prop 被识别(且获取)的特性绑定(`class` 和
              `style` 除外). 当一个组件没有声明任何 prop 时,
              这里会包含所有父作用域的绑定(`class` 和 `style` 除外),
              并且可以通过 `v-bind=$attrs` 传入内部组件 --
              这在创建高级别的组件时非常有用. <br/>
              (Tip: 大致意思就是子组件可以通过 `v-bind=$attr`
              来获取父组件的标签上除了 `class` 和 `style` 之外的不作为 prop
              被使用的所有特性(attribute))
      
      更多 `inheritAttrs` 的工作原理, 只有在学习源码时才可以看到了.